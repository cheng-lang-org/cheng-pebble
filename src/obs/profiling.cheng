module pebble_obs_profiling

import cheng/pebble/obs/events as obs_events
import cheng/pebble/obs/metrics as obs_metrics
import cheng/pebble/obs/types as obs_types
import std/std/times as times
import std/strings as strings


type
    ProfilingSink = fn(name: str, durationSeconds: float64)

    Profiler = ref
        enabled: bool
        sinks: seq[ProfilingSink]

fn NewProfiler(): Profiler =
    var profiler: Profiler = new[Profiler]()
    if profiler != nil:
        profiler.enabled = true
        profiler.sinks = @[]
    return profiler

fn RegisterSink(profiler: Profiler, sink: ProfilingSink) =
    if profiler == nil || sink == nil:
        return
    profiler.sinks.add(sink)

fn notifySinks(profiler: Profiler, name: str, duration: float64) =
    if profiler == nil:
        return
    var i: int32 = 0
    while i < profiler.sinks.len:
        let sink = profiler.sinks[i]
        if sink != nil:
            sink(name, duration)
        i = i + 1

fn ProfileBlock(profiler: Profiler,
                metrics: obs_metrics.MetricsRegistry,
                bus: obs_events.EventBus,
                name: str,
                labels: seq[obs_types.LabelPair] = @[],
                body: fn()) =
    if profiler == nil || ! profiler.enabled || body == nil:
        if body != nil:
            body()
        return
    let start = times.epochTime()
    body()
    let elapsed = times.epochTime() - start
    if metrics != nil:
        obs_metrics.ObserveHistogram(metrics, "pebble_profile_seconds",
            "Profiling duration", labels, elapsed)
    if bus != nil:
        let msg = "profiling block '" & name & "' completed"
        let event = obs_types.ObsEvent(
            kind: obs_types.ObsProfilingSample,
            timestamp: times.now(),
            message: msg,
            tags: obs_types.NewLabelPairs(labels),
            payload: "duration_seconds=" & toString(elapsed)
        )
        obs_events.Publish(bus, event)
    notifySinks(profiler, name, elapsed)
