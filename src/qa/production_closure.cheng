module pebble_qa_production_closure

import cheng/pebble/batch/db as batch_db
import cheng/pebble/batch/types as batch_types
import cheng/pebble/batch/interop as batch_interop
import cheng/pebble/core/types as core_types
import std/os as os
import std/strings as strings

fn ensureDir(path: str) =
    if strings.len(path) == 0:
        return
    if !os.dirExists(path):
        os.createDir(path)

fn pathIsFile(path: str): bool =
    if path == nil || strings.len(path) == 0:
        return false
    let handle = os.openRead(path)
    if handle == nil:
        return false
    os.close(handle)
    return true

fn DefaultProductionDbConfig(rootDir: str): batch_types.DBConfig =
    var cfg = batch_interop.DefaultDbConfig()
    cfg.sstableDir = rootDir
    cfg.manifestPath = os.joinPath(rootDir, "MANIFEST")
    cfg.walPath = os.joinPath(rootDir, "WAL.log")
    cfg.walMaxSegmentBytes = 256
    cfg.autoFlush = false
    cfg.enableRecovery = true
    cfg.createIfMissing = true
    cfg.replayTailTolerance = true
    cfg.resetWalOnFlush = false
    cfg.memConfig.softLimitBytes = 512 * 1024
    cfg.memConfig.hardLimitBytes = 4 * 1024 * 1024
    cfg.tableBlockSize = 4 * 1024
    cfg.tableBloomBitsPerKey = 10
    return cfg

fn RunProductionClosureScenario(rootDir: str): seq[str] =
    var findings: seq[str]
    ensureDir(rootDir)
    let cfg = DefaultProductionDbConfig(rootDir)

    var db = batch_db.InitDB(cfg)
    if db == nil:
        findings.add("failed to initialize db")
        return findings

    let seqAlpha = batch_db.Put(db, core_types.ToKey("alpha"), "1")
    let gotAlpha = batch_db.GetLatest(db, core_types.ToKey("alpha"))
    if !gotAlpha.has || gotAlpha.value != "1":
        findings.add("write/read validation failed")
    let seqDelete = batch_db.Delete(db, core_types.ToKey("alpha"))
    let gotDeleted = batch_db.GetLatest(db, core_types.ToKey("alpha"))
    if gotDeleted.has:
        findings.add("delete validation failed")
    var snapBeforeDelete: batch_types.Snapshot
    snapBeforeDelete.seq = seqAlpha
    let gotSnapshot = batch_db.Get(db, core_types.ToKey("alpha"), snapBeforeDelete)
    if !gotSnapshot.has || gotSnapshot.value != "1":
        findings.add("snapshot-before-delete validation failed")
    var snapAfterDelete: batch_types.Snapshot
    snapAfterDelete.seq = seqDelete
    let gotAfterDelete = batch_db.Get(db, core_types.ToKey("alpha"), snapAfterDelete)
    if gotAfterDelete.has:
        findings.add("snapshot-after-delete validation failed")
    batch_db.Put(db, core_types.ToKey("beta"), "2")
    batch_db.Close(db)

    db = batch_db.InitDB(cfg)
    if db == nil:
        findings.add("failed to reopen db")
        return findings
    let gotBeta = batch_db.GetLatest(db, core_types.ToKey("beta"))
    if !gotBeta.has || gotBeta.value != "2":
        findings.add("reopen persistence validation failed")
    batch_db.Put(db, core_types.ToKey("gamma"), "3")
    batch_db.Close(db)

    db = batch_db.InitDB(cfg)
    if db == nil:
        findings.add("failed to reopen db after second close")
        return findings
    let gotGamma = batch_db.GetLatest(db, core_types.ToKey("gamma"))
    if !gotGamma.has || gotGamma.value != "3":
        findings.add("second reopen persistence validation failed")
    batch_db.Close(db)

    if !pathIsFile(os.joinPath(rootDir, "MANIFEST")):
        findings.add("manifest file missing")
    if !pathIsFile(os.joinPath(rootDir, "WAL.log")):
        findings.add("wal file missing")
    if !pathIsFile(os.joinPath(rootDir, "L0-1.sst")):
        findings.add("no SSTable generated")

    return findings
