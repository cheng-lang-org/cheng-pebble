module pebble_mem_memtable

import cheng/pebble/core/types as core_types
import cheng/pebble/mem/types as mem_types
import cheng/pebble/runtime/executor as exec
import cheng/pebble/runtime/resource_manager as resource
import std/option as option
import std/strings as strings

const
    EntryOverhead = 16

type
    LookupResult = ref
        found: bool
        value: option.Option[str]

fn defaultComparator(): core_types.Comparator =
    return core_types.CompareBytewise

fn InitMemTable(cfg: mem_types.MemTableConfig): mem_types.MemTable =
    var table: mem_types.MemTable
    new table
    if table == nil:
        return table
    table.cfg = cfg
    var base: mem_types.Flushable
    new base
    table.base = base
    if table.base != nil:
        let baseRef = table.base
        if cfg.comparator != nil:
            baseRef.comparator = cfg.comparator
        else:
            baseRef.comparator = defaultComparator()
        baseRef.approxBytes = 0
        baseRef.frozen = false
    table.records = newSeq[mem_types.MemRecord]()
    table.bytesUsed = 0
    table.lastSeq = uint64(0)
    table.tickets = newSeq[resource.ResourceTicket]()
    table.flushScheduled = false
    table.throttleActive = false
    table.lastThrottleDelayMs = 0
    return table

fn verifySequence(mt: mem_types.MemTable, seq: core_types.SequenceNumber) =
    if uint64(seq) < uint64(mt.lastSeq):
        raise mem_types.MemError(msg: "sequence numbers must be monotonically increasing")

fn triggerFlush(mt: mem_types.MemTable) =
    let cfg = mt.cfg
    if cfg.flushTrigger == nil:
        return
    if mt.flushScheduled:
        return
    mt.flushScheduled = true
    let trigger = cfg.flushTrigger
    let target = mt.base
    cfg.flushExecutor
    trigger(target)

fn markFrozenForFlush(mt: mem_types.MemTable) =
    let baseRef = mt.base
    if baseRef != nil:
        baseRef.frozen = true
    triggerFlush(mt)

fn computeStallLimit(mt: mem_types.MemTable): int32 =
    let cfg = mt.cfg
    let throttle = cfg.throttleConfig
    if throttle.stallLimitBytes > 0:
        return throttle.stallLimitBytes
    return cfg.softLimitBytes

fn computeReleaseTarget(mt: mem_types.MemTable, stallLimit: int32): int32 =
    let cfg = mt.cfg
    let throttle = cfg.throttleConfig
    if throttle.releaseTargetBytes > 0:
        return throttle.releaseTargetBytes
    if stallLimit <= 0:
        return 0
    let reduction = max(1, stallLimit / 4)
    return max(0, stallLimit - reduction)

fn reserveBytes(mt: mem_types.MemTable, bytes: int32) =
    if bytes <= 0:
        return
    let cfg = mt.cfg
    let projected = mt.bytesUsed + bytes
    if cfg.hardLimitBytes > 0 && projected > cfg.hardLimitBytes:
        raise mem_types.MemError(msg: "memtable capacity exceeded (hard limit)")
    let rm = cfg.resourceManager
    if rm != nil:
        let ticket = resource.AcquireQuota(rm, cfg.resourceKind, bytes.int64)
        var tickets = mt.tickets
        tickets.add(ticket)
        mt.tickets = tickets
    mt.bytesUsed = projected
    let baseRef = mt.base
    if baseRef != nil:
        baseRef.approxBytes = projected
    if rm != nil && resource.IsSoftExceeded(rm, cfg.resourceKind):
        markFrozenForFlush(mt)

fn checkWritable(mt: mem_types.MemTable) =
    let baseRef = mt.base
    if baseRef != nil && baseRef.frozen:
        raise mem_types.MemError(msg: "memtable is frozen and cannot accept new writes")

fn estimateEntryBytes(key: core_types.Key, value: str): int32 =
    var keyBytes = core_types.ToBytes(key)
    if keyBytes == nil:
        keyBytes = ""
    var payload = value
    if payload == nil:
        payload = ""
    return strings.len(keyBytes) + strings.len(payload) + EntryOverhead

fn appendRecord(mt: mem_types.MemTable, key: core_types.Key,
                seq: core_types.SequenceNumber,
                kind: mem_types.MemValueKind,
                value: str) =
    checkWritable(mt)
    verifySequence(mt, seq)
    let sizeBytes = estimateEntryBytes(key, value)
    reserveBytes(mt, sizeBytes)
    var records = mt.records
    records.add(mem_types.MemRecord(key: key, seq: seq, kind: kind, value: value))
    mt.records = records
    if uint64(seq) >= uint64(mt.lastSeq):
        mt.lastSeq = seq
    let cfg = mt.cfg
    if cfg.softLimitBytes > 0 && mt.bytesUsed >= cfg.softLimitBytes:
        markFrozenForFlush(mt)

fn Put(mt: mem_types.MemTable, key: core_types.Key, value: str,
       seq: core_types.SequenceNumber) =
    appendRecord(mt, key, seq, mem_types.MemValueSet, value)

fn Delete(mt: mem_types.MemTable, key: core_types.Key,
          seq: core_types.SequenceNumber) =
    appendRecord(mt, key, seq, mem_types.MemValueDelete, "")

fn Merge(mt: mem_types.MemTable, key: core_types.Key,
         operand: str,
         seq: core_types.SequenceNumber) =
    if ! mem_types.HasMerge(mt.cfg):
        raise mem_types.MemError(msg: "merge requested without configured merge operator")
    appendRecord(mt, key, seq, mem_types.MemValueMerge, operand)

fn PrecheckApplyBatch(mt: mem_types.MemTable, entries: seq[mem_types.ApplyEntry]) =
    if mt == nil:
        raise mem_types.MemError(msg: "memtable is nil")
    checkWritable(mt)
    if len(entries) == 0:
        return
    let cfg = mt.cfg
    var projected = mt.bytesUsed
    var prevSeq = uint64(mt.lastSeq)
    var i: int32 = 0
    while i < len(entries):
        let entry = entries[i]
        let seqValue = uint64(entry.seq)
        if seqValue < prevSeq:
            raise mem_types.MemError(msg: "sequence numbers must be monotonically increasing")
        prevSeq = seqValue
        if entry.kind == mem_types.MemValueMerge && ! mem_types.HasMerge(mt.cfg):
            raise mem_types.MemError(msg: "merge requested without configured merge operator")
        let sizeBytes = estimateEntryBytes(entry.key, entry.value)
        if cfg.hardLimitBytes > 0 && projected + sizeBytes > cfg.hardLimitBytes:
            raise mem_types.MemError(msg: "memtable capacity exceeded (hard limit)")
        projected = projected + sizeBytes
        i = i + 1

fn ApplyBatch(mt: mem_types.MemTable, entries: seq[mem_types.ApplyEntry]) =
    if mt == nil:
        raise mem_types.MemError(msg: "memtable is nil")
    if len(entries) == 0:
        return
    PrecheckApplyBatch(mt, entries)
    var totalBytes: int32 = 0
    var i: int32 = 0
    while i < len(entries):
        let entry = entries[i]
        totalBytes = totalBytes + estimateEntryBytes(entry.key, entry.value)
        i = i + 1
    reserveBytes(mt, totalBytes)
    i = 0
    while i < len(entries):
        let entry = entries[i]
        var records = mt.records
        records.add(mem_types.MemRecord(
            key: entry.key,
            seq: entry.seq,
            kind: entry.kind,
            value: entry.value
        ))
        mt.records = records
        if uint64(entry.seq) >= uint64(mt.lastSeq):
            mt.lastSeq = entry.seq
        i = i + 1
    let cfg = mt.cfg
    if cfg.softLimitBytes > 0 && mt.bytesUsed >= cfg.softLimitBytes:
        markFrozenForFlush(mt)

fn AdmitWrite(mt: mem_types.MemTable,
              priority: mem_types.MemWritePriority,
              incomingBytes: int32): int32 =
    if mt == nil || incomingBytes <= 0:
        return 0
    let tableCfg = mt.cfg
    let cfg = tableCfg.throttleConfig
    let stallLimit = computeStallLimit(mt)
    if ! mem_types.ThrottleEnabled(cfg) || stallLimit <= 0:
        if mt.throttleActive:
            let releaseTarget = computeReleaseTarget(mt, max(stallLimit, 0))
            if releaseTarget <= 0 || mt.bytesUsed <= releaseTarget:
                mt.throttleActive = false
                mt.lastThrottleDelayMs = 0
        return 0
    let projected = mt.bytesUsed + incomingBytes
    let releaseTarget = computeReleaseTarget(mt, stallLimit)
    if projected < stallLimit:
        if mt.throttleActive && (releaseTarget <= 0 || projected <= releaseTarget):
            mt.throttleActive = false
            mt.lastThrottleDelayMs = 0
        return 0
    triggerFlush(mt)
    var effective = priority
    if effective == mem_types.MemPriorityDefault:
        effective = mem_types.MemPriorityNormal
    var scaleValue: float64 = 1.0
    if effective == mem_types.MemPriorityLow:
        scaleValue = cfg.priorityScaleLow
    elif effective == mem_types.MemPriorityNormal:
        scaleValue = cfg.priorityScaleNormal
    elif effective == mem_types.MemPriorityHigh:
        scaleValue = cfg.priorityScaleHigh
    if scaleValue <= 0.0:
        scaleValue = 1.0
    let baseDelay = max(1, cfg.baseDelayMs)
    let maxDelay = max(baseDelay, cfg.maxDelayMs)
    let over = projected - stallLimit
    var ratio = float64(over) / float64(max(1, stallLimit))
    if ratio > 1.0:
        ratio = 1.0
    let dynamic = int32(ratio * float64(maxDelay - baseDelay) * scaleValue)
    var delay = baseDelay + dynamic
    delay = max(baseDelay, delay)
    delay = min(maxDelay, delay)
    mt.throttleActive = true
    mt.lastThrottleDelayMs = delay
    return delay

fn mergeResolve(mt: mem_types.MemTable, key: core_types.Key,
                base: option.Option[str], operands: seq[str]): option.Option[str] =
    if operands.len == 0:
        return base
    if ! mem_types.HasMerge(mt.cfg):
        raise mem_types.MemError(msg: "merge resolution requested without operator")
    var ordered = newSeq[str](operands.len)
    var i: int32 = 0
    let last = operands.len - 1
    while i < operands.len:
        ordered[i] = operands[last - i]
        i = i + 1
    let cfg = mt.cfg
    return cfg.mergeOperator(key, base, ordered)

fn Lookup(mt: mem_types.MemTable,
          key: core_types.Key,
          snapshot: core_types.SequenceNumber): LookupResult =
    let snapValue = uint64(snapshot)
    var operands = newSeq[str]()
    var base = option.None[str]()
    var seen = false
    if mt == nil:
        return LookupResult(found: false, value: option.None[str]())
    let records = mt.records
    var idx: int32 = records.len - 1
    let baseRef = mt.base
    while idx >= 0:
        let record = records[idx]
        if baseRef != nil && baseRef.comparator != nil:
            if baseRef.comparator(key, record.key) != 0:
                if idx == 0:
                    break
                idx = idx - 1
                continue
        if uint64(record.seq) > snapValue:
            if idx == 0:
                break
            idx = idx - 1
            continue
        seen = true
        if record.kind == mem_types.MemValueSet:
            base = option.some(record.value)
            break
        elif record.kind == mem_types.MemValueDelete:
            base = option.None[str]()
            break
        else:
            operands.add(record.value)
        if idx == 0:
            break
        idx = idx - 1
    if ! seen:
        return LookupResult(found: false, value: option.None[str]())
    if operands.len == 0:
        return LookupResult(found: true, value: base)
    return LookupResult(found: true, value: mergeResolve(mt, key, base, operands))

fn Get(mt: mem_types.MemTable,
       key: core_types.Key,
       snapshot: core_types.SequenceNumber): option.Option[str] =
    let hit = Lookup(mt, key, snapshot)
    if hit.found:
        return hit.value
    return option.None[str]()

fn GetLatest(mt: mem_types.MemTable, key: core_types.Key): option.Option[str] =
    let hit = Lookup(mt, key, uint64(0xFFFFFFFFFFFFFFFF))
    if hit != nil && hit.found:
        return hit.value
    return option.None[str]()

fn Freeze(mt: mem_types.MemTable) =
    let baseRef = mt.base
    if baseRef != nil:
        baseRef.frozen = true

fn ReadyForFlush(mt: mem_types.MemTable): bool =
    let baseRef = mt.base
    if baseRef == nil:
        return false
    return baseRef.frozen

fn NeedsFlush(mt: mem_types.MemTable): bool =
    let cfg = mt.cfg
    if cfg.softLimitBytes > 0 && mt.bytesUsed >= cfg.softLimitBytes:
        return true
    if cfg.resourceManager != nil:
        return resource.IsSoftExceeded(cfg.resourceManager, cfg.resourceKind)
    return false

fn Clear(mt: mem_types.MemTable) =
    if mt == nil:
        return
    let cfg = mt.cfg
    if cfg.resourceManager != nil:
        let existingTickets = mt.tickets
        var i: int32 = 0
        while i < existingTickets.len:
            resource.Release(cfg.resourceManager, existingTickets[i])
            i = i + 1
    var tickets = mt.tickets
    tickets.setLen(0)
    mt.tickets = tickets
    var records = mt.records
    records.setLen(0)
    mt.records = records
    mt.bytesUsed = 0
    let baseRef = mt.base
    if baseRef != nil:
        baseRef.approxBytes = 0
        baseRef.frozen = false
    mt.lastSeq = uint64(0)
    mt.flushScheduled = false
    mt.throttleActive = false
    mt.lastThrottleDelayMs = 0

fn MarkFlushCompleted(mt: mem_types.MemTable) =
    if mt == nil:
        return
    mt.flushScheduled = false
    let baseRef = mt.base
    if baseRef != nil:
        baseRef.frozen = false
    mt.throttleActive = false
    mt.lastThrottleDelayMs = 0

fn RecordCount(mt: mem_types.MemTable): int32 =
    if mt == nil:
        return 0
    return mt.records.len

fn RecordAt(mt: mem_types.MemTable, idx: int32): mem_types.MemRecord =
    if mt == nil:
        raise mem_types.MemError(msg: "memtable record index out of range")
    if idx < 0:
        raise mem_types.MemError(msg: "memtable record index out of range")
    let records = mt.records
    if idx >= records.len:
        raise mem_types.MemError(msg: "memtable record index out of range")
    return records[idx]

fn ApproxBytes(mt: mem_types.MemTable): int32 =
    if mt == nil:
        return 0
    let baseRef = mt.base
    if baseRef == nil:
        return 0
    return baseRef.approxBytes
