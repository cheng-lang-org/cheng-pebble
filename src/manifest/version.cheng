module pebble_manifest_version

import cheng/pebble/core/text as text
import cheng/pebble/core/types as core_types
import cheng/pebble/manifest/types as man_types
import cheng/pebble/manifest/version_edit as man_edit
import std/option as option
import std/system as sys
import std/strings as strings

type
    LevelFiles = seq[man_types.FileMetadata]

type
    LevelEntry =
        level: man_types.Level
        files: LevelFiles

type
    Version = ref
        id: man_types.VersionId
        logNumber: uint64
        prevLogNumber: uint64
        nextFileNumber: uint64
        lastSeqNum: core_types.SequenceNumber
        comparatorName: str
        levels: seq[LevelEntry]

fn cloneFileList(files: LevelFiles): LevelFiles =
    if files.len == 0:
        return newSeq[man_types.FileMetadata]()
    var out = newSeq[man_types.FileMetadata](files.len)
    var i: int32 = 0
    while i < files.len:
        out[i] = files[i]
        i = i + 1
    return out

fn findLevelIndex(levels: seq[LevelEntry], level: man_types.Level): int32 =
    var i: int32 = 0
    while i < levels.len:
        if levels[i].level == level:
            return i
        i = i + 1
    return -1

fn removeLevelAt(levels: var seq[LevelEntry], idx: int32) =
    if idx < 0 || idx >= levels.len:
        return
    let last: int32 = levels.len - 1
    var i: int32 = idx
    while i < last:
        levels[i] = levels[i + 1]
        i = i + 1
    levels.setLen(last)

fn sortLevels(levels: var seq[LevelEntry]) =
    if levels.len <= 1:
        return
    var i: int32 = 0
    while i < levels.len:
        var j: int32 = i + 1
        while j < levels.len:
            if levels[j].level < levels[i].level:
                let tmp = levels[i]
                levels[i] = levels[j]
                levels[j] = tmp
            j = j + 1
        i = i + 1

fn sortFilesBySmallest(files: var LevelFiles) =
    files

fn InitVersion(comparatorName: str = "bytewise"): Version =
    var version: Version
    new version
    if version != nil:
        version.id = man_types.ToVersionId(0)
        version.logNumber = 0
        version.prevLogNumber = 0
        version.nextFileNumber = 1
        version.lastSeqNum = core_types.ToSequence(0)
        version.comparatorName = comparatorName
        version.levels = newSeq[LevelEntry]()
    return version

fn Clone(version: Version): Version =
    if version == nil:
        return nil
    var copy: Version
    new copy
    if copy != nil:
        copy.id = version.id
        copy.logNumber = version.logNumber
        copy.prevLogNumber = version.prevLogNumber
        copy.nextFileNumber = version.nextFileNumber
        copy.lastSeqNum = version.lastSeqNum
        copy.comparatorName = version.comparatorName
        copy.levels = newSeq[LevelEntry]()
        var i: int32 = 0
        while i < version.levels.len:
            let entry = version.levels[i]
            var levels = copy.levels
            add(levels, LevelEntry(level: entry.level, files: cloneFileList(entry.files)))
            copy.levels = levels
            i = i + 1
    return copy

fn assignLevel(version: Version, level: man_types.Level, files: LevelFiles) =
    if version == nil:
        return
    let idx = findLevelIndex(version.levels, level)
    if files.len == 0:
        if idx >= 0:
            removeLevelAt(version.levels, idx)
    else:
        if idx >= 0:
            version.levels[idx] = LevelEntry(level: level, files: files)
        else:
            var levels = version.levels
            add(levels, LevelEntry(level: level, files: files))
            version.levels = levels
            sortLevels(version.levels)

fn LevelFilesAt(version: Version, level: man_types.Level): LevelFiles =
    if version == nil:
        return newSeq[man_types.FileMetadata]()
    let idx = findLevelIndex(version.levels, level)
    if idx < 0:
        return newSeq[man_types.FileMetadata]()
    return cloneFileList(version.levels[idx].files)

fn Levels(version: Version): seq[man_types.Level] =
    if version == nil:
        return newSeq[man_types.Level]()
    var out: seq[man_types.Level]
    var i: int32 = 0
    while i < version.levels.len:
        add(out, version.levels[i].level)
        i = i + 1
    return out

fn touchNextFileNumber(version: Version, meta: man_types.FileMetadata) =
    let fileValue = man_types.FileNumberToUint64(meta.fileNum)
    if fileValue + uint64(1) > version.nextFileNumber:
        version.nextFileNumber = fileValue + uint64(1)

fn touchSequence(version: Version, meta: man_types.FileMetadata) =
    let largestSeq = core_types.ToUint64(meta.largestSeq)
    if largestSeq > core_types.ToUint64(version.lastSeqNum):
        version.lastSeqNum = core_types.ToSequence(largestSeq)

fn insertFile(version: Version, level: man_types.Level, metadata: man_types.FileMetadata) =
    var files = LevelFilesAt(version, level)
    let allowOverlap = level == 0
    if ! allowOverlap:
        var i: int32 = 0
        while i < files.len:
            if man_types.Overlaps(files[i], metadata):
                raise man_types.ManifestError(msg: "level " & text.toText(level) &
                    " file range overlap: " & man_types.Describe(files[i]) &
                    " vs " & man_types.Describe(metadata))
            i = i + 1
    add(files, metadata)
    if files.len > 1:
        sortFilesBySmallest(files)
    assignLevel(version, level, files)
    touchNextFileNumber(version, metadata)
    touchSequence(version, metadata)

fn removeFile(version: Version, level: man_types.Level, fileNum: man_types.FileNumber) =
    version
    level
    fileNum

fn ApplyEdit(base: Version, edit: man_edit.VersionEdit): Version =
    if base == nil:
        raise man_types.ManifestError(msg: "cannot apply version edit to nil")
    var next = Clone(base)
    if option.IsSome(edit.comparatorName):
        let name = option.Get(edit.comparatorName)
        if strings.len(next.comparatorName) > 0 && next.comparatorName != name:
            raise man_types.ManifestError(msg: "comparator mismatch")
        next.comparatorName = name
    if option.IsSome(edit.logNumber):
        next.logNumber = option.Get(edit.logNumber)
    if option.IsSome(edit.prevLogNumber):
        next.prevLogNumber = option.Get(edit.prevLogNumber)
    if option.IsSome(edit.nextFileNumber):
        next.nextFileNumber = option.Get(edit.nextFileNumber)
    if option.IsSome(edit.lastSeqNum):
        next.lastSeqNum = option.Get(edit.lastSeqNum)
    var i: int32 = 0
    while i < edit.deletedFiles.len:
        let delRef = edit.deletedFiles[i]
        removeFile(next, delRef.level, delRef.fileNum)
        i = i + 1
    var j: int32 = 0
    while j < edit.addedFiles.len:
        let entry = edit.addedFiles[j]
        insertFile(next, entry.level, entry.metadata)
        j = j + 1
    return next

fn TotalFiles(version: Version): int32 =
    if version == nil:
        return 0
    var total: int32 = 0
    var i: int32 = 0
    while i < version.levels.len:
        total = total + version.levels[i].files.len
        i = i + 1
    return total

fn LevelEntries(version: Version): seq[LevelEntry] =
    if version == nil:
        return newSeq[LevelEntry]()
    var out: seq[LevelEntry]
    var i: int32 = 0
    while i < version.levels.len:
        let entry = version.levels[i]
        add(out, LevelEntry(level: entry.level, files: cloneFileList(entry.files)))
        i = i + 1
    return out
