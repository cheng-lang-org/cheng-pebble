module pebble_sstable_filter

import cheng/pebble/core/types as core_types
import cheng/pebble/sstable/types as sstable_types
import cheng/pebble/sstable/encoding as enc
import std/system as sys
import std/strings as strings

const
    MinBloomBits = 64

type
    BloomFilterBuilder =
        bitsPerKey: int32
        keys: seq[str]

    BloomBuildResult =
        data: seq[uint8]
        filter: sstable_types.BloomFilter

fn clampProbes(value: int32): int32 =
    if value < 1:
        return 1
    if value > 16:
        return 16
    return value

fn OptimalProbes(bitsPerKey: int32): int32 =
    if bitsPerKey <= 0:
        return 1
    let approx = (bitsPerKey * 69 + 50) / 100
    return clampProbes(approx)

fn hashMix(key: str, salt: uint32): uint32 =
    var h: uint32 = uint32(2166136261)
    var i: int32 = 0
    let n: int32 = strings.len(key)
    while i < n:
        let ch = key[i]
        h = (h ^ uint32(int32(ch))) * uint32(16777619)
        i = i + 1
    h = h ^ salt
    h = h * uint32(16777619)
    return h ^ (h >> 16)

fn InitBloomFilterBuilder(bitsPerKey: int32): BloomFilterBuilder =
    if bitsPerKey <= 0:
        raise sstable_types.SSTError(msg: "bitsPerKey must be positive")
    return BloomFilterBuilder(bitsPerKey: bitsPerKey, keys: newSeq[str]())

fn AddKey(builder: var BloomFilterBuilder, key: core_types.Key) =
    var keys = builder.keys
    add(keys, core_types.ToBytes(key))
    builder.keys = keys

fn buildFilter(keys: seq[str], bitsPerKey: int32): sstable_types.BloomFilter =
    let numProbes = OptimalProbes(bitsPerKey)
    if keys.len == 0:
        return sstable_types.BloomFilter(bits: newSeq[uint8](), numBits: 0, numProbes: numProbes)
    var numBits: int32 = keys.len * bitsPerKey
    if numBits < MinBloomBits:
        numBits = MinBloomBits
    let numBytes = (numBits + 7) >> 3
    var bits = newSeq[uint8](numBytes)
    let salt1 = uint32(0x47c6a7e5)
    let salt2 = uint32(0x9e3779b1)
    var i: int32 = 0
    while i < keys.len:
        let key = keys[i]
        let h1 = hashMix(key, salt1)
        let h2 = hashMix(key, salt2)
        var n: int32 = 0
        while n < numProbes:
            let combined = h1 + uint32(n) * h2
            let bitPos = int32(combined % uint32(numBits))
            let byteIdx = bitPos >> 3
            let mask = uint8(1 << (bitPos & 7))
            bits[byteIdx] = bits[byteIdx] | mask
            n = n + 1
        i = i + 1
    return sstable_types.BloomFilter(bits: bits, numBits: numBits, numProbes: numProbes)

fn EncodeBloomFilter(filter: sstable_types.BloomFilter): seq[uint8] =
    var out = newSeq[uint8]()
    enc.AppendVarint(out, uint64(filter.numBits))
    enc.AppendVarint(out, uint64(filter.numProbes))
    var i: int32 = 0
    while i < filter.bits.len:
        add(out, filter.bits[i])
        i = i + 1
    return out

fn Finish(builder: var BloomFilterBuilder): BloomBuildResult =
    let filter = buildFilter(builder.keys, builder.bitsPerKey)
    let data = EncodeBloomFilter(filter)
    builder.keys = newSeq[str]()
    return BloomBuildResult(data: data, filter: filter)

fn DecodeBloomFilter(data: seq[uint8]): sstable_types.BloomFilter =
    if data.len == 0:
        return sstable_types.BloomFilter(bits: newSeq[uint8](), numBits: 0, numProbes: 0)
    var pos: int32 = 0
    let numBits = int32(enc.DecodeVarint(data, &pos))
    let numProbes = int32(enc.DecodeVarint(data, &pos))
    if pos > data.len:
        raise sstable_types.SSTError(msg: "invalid bloom filter encoding")
    let remaining = data.len - pos
    var bits = newSeq[uint8](remaining)
    var idx: int32 = 0
    while idx < remaining:
        bits[idx] = data[pos + idx]
        idx = idx + 1
    return sstable_types.BloomFilter(bits: bits, numBits: numBits, numProbes: numProbes)

fn MaybeContains(filter: sstable_types.BloomFilter, key: core_types.Key): bool =
    if filter.numBits == 0 || filter.bits.len == 0:
        return true
    let salt1 = uint32(0x47c6a7e5)
    let salt2 = uint32(0x9e3779b1)
    let keyBytes = core_types.ToBytes(key)
    let h1 = hashMix(keyBytes, salt1)
    let h2 = hashMix(keyBytes, salt2)
    var n: int32 = 0
    while n < filter.numProbes:
        let combined = h1 + uint32(n) * h2
        let bitPos = int32(combined % uint32(filter.numBits))
        let byteIdx = bitPos >> 3
        let mask = uint8(1 << (bitPos & 7))
        if (filter.bits[byteIdx] & mask) == uint8(0):
            return false
        n = n + 1
    return true
