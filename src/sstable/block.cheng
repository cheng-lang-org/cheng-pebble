module pebble_sstable_block

import cheng/pebble/core/types as core_types
import cheng/pebble/sstable/types as sstable_types
import cheng/pebble/sstable/encoding as enc
import std/option as option
import std/strings as strings

const
    PrefixCompressedMagic = "\xffPC"

type
    BlockEntry = ref
        key: core_types.Key
        value: str

type
    BlockBuildResult =
        payload: seq[uint8]
        firstKey: core_types.Key
        lastKey: core_types.Key
        numEntries: int32
        rawKeySize: int32
        rawValueSize: int32
        encoding: sstable_types.BlockEncoding

type
    BlockBuilder =
        entries: seq[BlockEntry]
        approxSize: int32
        prefixCompression: bool

type
    BlockItem = ref
        key: core_types.Key
        value: str

type
    BlockIterator =
        data: seq[uint8]
        pos: int32
        encoding: sstable_types.BlockEncoding
        remaining: int32
        lastKey: str

fn InitBlockBuilder(prefixCompression: bool = false): BlockBuilder =
    return BlockBuilder(entries: newSeq[BlockEntry](), approxSize: 0, prefixCompression: prefixCompression)

fn someBlockItem(value: BlockItem): option.Option[BlockItem] =
    var out: option.Option[BlockItem]
    out.has = true
    out.value = value
    return out

fn takePrefix(text: str, count: int32): str =
    if text == nil || count <= 0:
        return ""
    var limit = count
    if limit > strings.len(text):
        limit = strings.len(text)
    var out: str = ""
    var i: int32 = 0
    while i < limit:
        out = out + strings.charToStr(text[i])
        i = i + 1
    return out

fn decodeLegacy(it: var BlockIterator): option.Option[BlockItem] =
    if it.pos >= it.data.len:
        return option.None[BlockItem]()
    let keyBytes = enc.ReadBytes(it.data, &it.pos)
    let valueBytes = enc.ReadBytes(it.data, &it.pos)
    return someBlockItem(BlockItem(key: core_types.ToKey(keyBytes), value: valueBytes))

fn decodePrefixCompressed(it: var BlockIterator): option.Option[BlockItem] =
    if it.remaining == 0:
        return option.None[BlockItem]()
    it.remaining = it.remaining - 1
    let shared = int32(enc.DecodeVarint(it.data, &it.pos))
    if shared < 0 || shared > strings.len(it.lastKey):
        raise sstable_types.SSTError(msg: "invalid shared prefix length")
    let suffix = enc.ReadBytes(it.data, &it.pos)
    let valueBytes = enc.ReadBytes(it.data, &it.pos)
    var keyBytes: str
    if shared == 0:
        keyBytes = suffix
    else:
        keyBytes = takePrefix(it.lastKey, shared) & suffix
    it.lastKey = keyBytes
    return someBlockItem(BlockItem(key: core_types.ToKey(keyBytes), value: valueBytes))

fn IsEmpty(builder: BlockBuilder): bool =
    return builder.entries.len == 0

fn EstimatedSize(builder: BlockBuilder): int32 =
    return builder.approxSize + builder.entries.len * 5

fn Add(builder: var BlockBuilder, key: core_types.Key, value: str) =
    builder.entries.add(BlockEntry(key: key, value: value))
    builder.approxSize = builder.approxSize + strings.len(core_types.ToBytes(key)) + strings.len(value)

fn appendSeq(dst: var seq[uint8], src: seq[uint8]) =
    var i: int32 = 0
    while i < src.len:
        dst.add(src[i])
        i = i + 1

fn encodePrefixCompressed(entries: seq[BlockEntry]): seq[uint8] =
    var buffer: seq[uint8]
    enc.AppendVarint(buffer, uint64(entries.len))
    var lastKey: str = ""
    var i: int32 = 0
    while i < entries.len:
        let entry = entries[i]
        let keyBytes = core_types.ToBytes(entry.key)
        let lastLen: int32 = strings.len(lastKey)
        let keyLen: int32 = strings.len(keyBytes)
        var shared: int32 = 0
        while shared < lastLen && shared < keyLen &&
            lastKey[shared] == keyBytes[shared]:
            shared = shared + 1
        enc.AppendVarint(buffer, uint64(shared))
        let suffix = if shared >= keyLen: "" else: keyBytes[shared..keyLen - 1]
        enc.AppendBytes(buffer, suffix)
        enc.AppendBytes(buffer, entry.value)
        lastKey = keyBytes
        i = i + 1
    var out: seq[uint8]
    enc.AppendStrBytes(out, PrefixCompressedMagic)
    appendSeq(out, buffer)
    return out

fn Finish(builder: var BlockBuilder): BlockBuildResult =
    if builder.entries.len == 0:
        raise sstable_types.SSTError(msg: "cannot finish empty block")
    let entries = builder.entries
    var result: BlockBuildResult
    if builder.prefixCompression:
        result.payload = encodePrefixCompressed(entries)
        result.encoding = sstable_types.BlockEncodingPrefixCompressed
    else:
        var buffer: seq[uint8]
        var i: int32 = 0
        while i < entries.len:
            let entry = entries[i]
            enc.AppendBytes(buffer, core_types.ToBytes(entry.key))
            enc.AppendBytes(buffer, entry.value)
            i = i + 1
        result.payload = buffer
        result.encoding = sstable_types.BlockEncodingLegacy
    let firstEntry = entries[0]
    let lastEntry = entries[entries.len - 1]
    result.firstKey = firstEntry.key
    result.lastKey = lastEntry.key
    result.numEntries = entries.len
    result.rawKeySize = 0
    result.rawValueSize = 0
    var j: int32 = 0
    while j < entries.len:
        let entry = entries[j]
        result.rawKeySize = result.rawKeySize + strings.len(core_types.ToBytes(entry.key))
        result.rawValueSize = result.rawValueSize + strings.len(entry.value)
        j = j + 1
    builder.entries = newSeq[BlockEntry]()
    builder.approxSize = 0
    return result

fn InitBlockIterator(data: seq[uint8]): BlockIterator =
    let magicLen: int32 = strings.len(PrefixCompressedMagic)
    if data.len >= magicLen:
        var matched: bool = true
        var i: int32 = 0
        while i < magicLen:
            let want = uint8(PrefixCompressedMagic[i])
            if data[i] != want:
                matched = false
                break
            i = i + 1
        if matched:
            var pos: int32 = magicLen
            let count = int32(enc.DecodeVarint(data, &pos))
            return BlockIterator(data: data, pos: pos,
                encoding: sstable_types.BlockEncodingPrefixCompressed,
                remaining: count, lastKey: "")
    return BlockIterator(data: data, pos: 0, encoding: sstable_types.BlockEncodingLegacy,
        remaining: -1, lastKey: "")

fn Next(it: var BlockIterator): option.Option[BlockItem] =
    if it.encoding == sstable_types.BlockEncodingPrefixCompressed:
        return decodePrefixCompressed(it)
    return decodeLegacy(it)
