module pebble_compaction_scheduler

import cheng/pebble/core/text as text
import cheng/pebble/compaction/types as comp_types
import cheng/pebble/compaction/planner as comp_planner
import cheng/pebble/runtime/executor as exec
import cheng/pebble/runtime/resource_manager as resource
import cheng/pebble/manifest/version as man_version
import std/option as option
import std/seqs as seqs
import std/system as sys
import std/tables as tables
import std/strings as strings


type
    CompactionSchedulerConfig =
        maxConcurrentJobs: int32
        acquireAmount: int64
        eventBufferLimit: int32
        executor: exec.Executor
        resourceManager: resource.ResourceManager
        resourceKind: resource.ResourceKind

type
    TicketResult =
        granted: bool
        ticket: option.Option[resource.ResourceTicket]

type
    CompactionScheduler = ref
        cfg: CompactionSchedulerConfig
        planner: comp_planner.CompactionPlanner
        handler: comp_types.CompactionJobHandler
        activeJobs: int32
        pending: seq[comp_types.CompactionPlan]
        metrics: comp_types.CompactionMetrics
        events: seq[comp_types.CompactionEvent]
        planRegistry: tables.Table[comp_types.CompactionPlan]
        planResults: tables.Table[comp_types.CompactionResult]

    ReleaseTicketReq = ref
        sched: CompactionScheduler
        ticketOpt: option.Option[resource.ResourceTicket]

    FailureEventReq = ref
        sched: CompactionScheduler
        planId: uint64
        message: str

fn normalizeConfig(cfg: CompactionSchedulerConfig): CompactionSchedulerConfig =
    var out = cfg
    if out.maxConcurrentJobs <= 0:
        out.maxConcurrentJobs = 1
    if out.eventBufferLimit <= 0:
        out.eventBufferLimit = 256
    return out

fn uint64ToStr(value: uint64): str =
    return text.toText(value)

fn int64ToStr(value: int64): str =
    return text.toText(value)

fn planKey(planId: uint64): str =
    return uint64ToStr(planId)

fn requestTicket(sched: CompactionScheduler): TicketResult =
    if sched == nil:
        return TicketResult(granted: false, ticket: option.None[resource.ResourceTicket]())
    let rm = sched.cfg.resourceManager
    if rm == nil || sched.cfg.acquireAmount <= 0:
        return TicketResult(granted: true, ticket: option.None[resource.ResourceTicket]())
    let idx: int32 = int32(sched.cfg.resourceKind)
    if ! rm.hasQuota[idx]:
        return TicketResult(granted: true, ticket: option.None[resource.ResourceTicket]())
    if resource.IsSoftExceeded(rm, sched.cfg.resourceKind):
        return TicketResult(granted: false, ticket: option.None[resource.ResourceTicket]())
    let ticket = resource.AcquireQuota(rm, sched.cfg.resourceKind, sched.cfg.acquireAmount)
    return TicketResult(granted: true, ticket: option.some(ticket))

fn releaseTicket(sched: CompactionScheduler, ticketOpt: option.Option[resource.ResourceTicket]) =
    if sched == nil || sched.cfg.resourceManager == nil:
        return
    if option.IsSome(ticketOpt):
        resource.Release(sched.cfg.resourceManager, option.Get(ticketOpt))

fn releaseTicketReq(req: ReleaseTicketReq) =
    if req == nil:
        return
    releaseTicket(req.sched, req.ticketOpt)

fn recordEvent(sched: CompactionScheduler,
               kind: comp_types.CompactionEventKind,
               planId: uint64,
               message: str,
               payload: str = "") =
    if sched == nil:
        return
    sched.events.add(comp_types.CompactionEvent(
        kind: kind,
        planId: planId,
        timestampMs: comp_types.NowTimestampMs(),
        message: message,
        payload: payload
    ))
    if sched.events.len > sched.cfg.eventBufferLimit:
        let overflow = sched.events.len - sched.cfg.eventBufferLimit
        var i: int32 = 0
        while i < overflow:
            seqs.delete[comp_types.CompactionEvent](&sched.events, 0)
            i = i + 1

fn emitFailureEvent(req: FailureEventReq) =
    if req == nil:
        return
    recordEvent(req.sched, comp_types.CompactionFailure, req.planId,
        "plan " & uint64ToStr(req.planId) & " failed", req.message)

fn updateMetrics(sched: CompactionScheduler, result: comp_types.CompactionResult) =
    sched.metrics.totalJobs = sched.metrics.totalJobs + 1
    sched.metrics.bytesRead = sched.metrics.bytesRead + result.bytesRead
    sched.metrics.bytesWritten = sched.metrics.bytesWritten + result.bytesWritten
    let writeAmp = comp_types.WriteAmplification(result)
    sched.metrics.lastWriteAmp = writeAmp
    if writeAmp > sched.metrics.maxWriteAmp:
        sched.metrics.maxWriteAmp = writeAmp
    if sched.metrics.bytesRead > 0:
        sched.metrics.avgWriteAmp = sched.metrics.bytesWritten.float / sched.metrics.bytesRead.float
    if result.readAmp >= 0.0:
        sched.metrics.readAmpSamples.add(result.readAmp)
        if sched.metrics.readAmpSamples.len > 128:
            sched.metrics.readAmpSamples.delete(0)

fn InitCompactionScheduler(planner: comp_planner.CompactionPlanner,
                           handler: comp_types.CompactionJobHandler,
                           cfg: CompactionSchedulerConfig): CompactionScheduler =
    if planner == nil:
        raise comp_types.CompactionError(msg: "planner is nil")
    if handler == nil:
        raise comp_types.CompactionError(msg: "handler is nil")
    var sched: CompactionScheduler
    new sched
    if sched != nil:
        sched.cfg = normalizeConfig(cfg)
        sched.planner = planner
        sched.handler = handler
        sched.activeJobs = 0
        sched.pending = @[]
        sched.metrics = comp_types.CompactionMetrics()
        sched.events = @[]
        sched.planRegistry = tables.TableInit[comp_types.CompactionPlan](32)
        sched.planResults = tables.TableInit[comp_types.CompactionResult](32)
    return sched

fn runPlan(sched: CompactionScheduler,
           plan: comp_types.CompactionPlan,
           ticketOpt: option.Option[resource.ResourceTicket]) =
    if sched == nil:
        return
    let key = planKey(plan.id)
    let releaseReq = ReleaseTicketReq(sched: sched, ticketOpt: ticketOpt)
    tables.TablePut[comp_types.CompactionPlan](sched.planRegistry, key, plan)
    recordEvent(sched, comp_types.CompactionStart, plan.id,
        "plan " & uint64ToStr(plan.id) & " start", plan.strategy)
    sched.activeJobs = sched.activeJobs + 1
    var caught: CatchableError = nil
    try:
        let result = sched.handler(plan)
        tables.TablePut[comp_types.CompactionResult](sched.planResults, key, result)
        updateMetrics(sched, result)
        recordEvent(sched, comp_types.CompactionFinish, plan.id,
            "plan " & uint64ToStr(plan.id) & " finished",
            "bytesRead=" & int64ToStr(result.bytesRead) &
            ",bytesWritten=" & int64ToStr(result.bytesWritten))
    except CatchableError as err:
        caught = err
    if sched.activeJobs > 0:
        sched.activeJobs = sched.activeJobs - 1
    releaseTicketReq(releaseReq)
    if caught != nil:
        let failure = FailureEventReq(sched: sched, planId: plan.id, message: caught.msg)
        emitFailureEvent(failure)
        raise caught

fn ScheduleNext(sched: CompactionScheduler,
                version: man_version.Version): option.Option[comp_types.CompactionPlan] =
    if sched == nil || sched.planner == nil:
        return option.None[comp_types.CompactionPlan]()
    if sched.activeJobs >= sched.cfg.maxConcurrentJobs:
        return option.None[comp_types.CompactionPlan]()
    if sched.pending.len > 0:
        let plan = sched.pending[0]
        let ticket = requestTicket(sched)
        if ! ticket.granted:
            return option.None[comp_types.CompactionPlan]()
        sched.pending.delete(0)
        runPlan(sched, plan, ticket.ticket)
        return option.some(plan)
    var telemetry = comp_types.DefaultTelemetry()
    let planOpt = comp_planner.NextPlan(sched.planner, version, telemetry)
    if ! option.IsSome(planOpt):
        return option.None[comp_types.CompactionPlan]()
    let plan = option.Get(planOpt)
    let ticket = requestTicket(sched)
    if ! ticket.granted:
        sched.pending.add(plan)
        return option.None[comp_types.CompactionPlan]()
    runPlan(sched, plan, ticket.ticket)
    return option.some(plan)

fn Metrics(sched: CompactionScheduler): comp_types.CompactionMetrics =
    if sched == nil:
        return comp_types.CompactionMetrics()
    return sched.metrics

fn Events(sched: CompactionScheduler): seq[comp_types.CompactionEvent] =
    if sched == nil:
        return @[]
    return sched.events

fn PlanResult(sched: CompactionScheduler, planId: uint64): option.Option[comp_types.CompactionResult] =
    if sched == nil:
        return option.None[comp_types.CompactionResult]()
    let key = planKey(planId)
    if tables.TableHas[comp_types.CompactionResult](sched.planResults, key):
        return option.some(tables.TableGet[comp_types.CompactionResult](sched.planResults, key))
    return option.None[comp_types.CompactionResult]()
