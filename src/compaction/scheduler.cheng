module pebble_compaction_scheduler

import "./types.cheng" as comp_types
import "./planner.cheng" as comp_planner
import "../runtime/executor.cheng" as exec
import "../runtime/resource_manager.cheng" as resource
import "../manifest/version.cheng" as man_version
import cheng / stdlib / bootstrap / core / option as option
import cheng / stdlib / bootstrap / seqs as seqs
import cheng / stdlib / bootstrap / tables as tables
import cheng / stdlib / bootstrap / strings as strings


type
    CompactionSchedulerConfig =
        maxConcurrentJobs: int32
        acquireAmount: int64
        eventBufferLimit: int32
        executor: exec.Executor
        resourceManager: resource.ResourceManager
        resourceKind: resource.ResourceKind

type
    TicketResult =
        granted: bool
        ticket: option.Option[resource.ResourceTicket]

type
    CompactionScheduler = ref
        cfg: CompactionSchedulerConfig
        planner: comp_planner.CompactionPlanner
        handler: comp_types.CompactionJobHandler
        activeJobs: int32
        pending: seq[comp_types.CompactionPlan]
        metrics: comp_types.CompactionMetrics
        events: seq[comp_types.CompactionEvent]
        planRegistry: tables.Table[comp_types.CompactionPlan]
        planResults: tables.Table[comp_types.CompactionResult]

fn normalizeConfig(cfg: CompactionSchedulerConfig): CompactionSchedulerConfig =
    var out = cfg
    if out.maxConcurrentJobs <= 0:
        out.maxConcurrentJobs = 1
    if out.eventBufferLimit <= 0:
        out.eventBufferLimit = 256
    return out

fn uint64ToStr(value: uint64): str =
    return strings.`$`(value)

fn int64ToStr(value: int64): str =
    return strings.`$`(value)

fn planKey(planId: uint64): str =
    return uint64ToStr(planId)

fn requestTicket(sched: CompactionScheduler): TicketResult =
    if sched == nil:
        return TicketResult(granted: false, ticket: option.none(resource.ResourceTicket))
    let rm = sched.cfg.resourceManager
    if rm == nil or sched.cfg.acquireAmount <= 0:
        return TicketResult(granted: true, ticket: option.none(resource.ResourceTicket))
    let idx: int32 = int32(sched.cfg.resourceKind)
    if not rm.hasQuota[idx]:
        return TicketResult(granted: true, ticket: option.none(resource.ResourceTicket))
    if resource.IsSoftExceeded(rm, sched.cfg.resourceKind):
        return TicketResult(granted: false, ticket: option.none(resource.ResourceTicket))
    let ticket = resource.AcquireQuota(rm, sched.cfg.resourceKind, sched.cfg.acquireAmount)
    return TicketResult(granted: true, ticket: option.some(ticket))

fn releaseTicket(sched: CompactionScheduler, ticketOpt: option.Option[resource.ResourceTicket]) =
    if sched == nil or sched.cfg.resourceManager == nil:
        return
    if option.IsSome(ticketOpt):
        resource.Release(sched.cfg.resourceManager, option.Get(ticketOpt))

fn recordEvent(sched: CompactionScheduler,
               kind: comp_types.CompactionEventKind,
               planId: uint64,
               message: str,
               payload: str = "") =
    if sched == nil:
        return
    sched.events.add(comp_types.CompactionEvent(
        kind: kind,
        planId: planId,
        timestampMs: comp_types.NowTimestampMs(),
        message: message,
        payload: payload
    ))
    if sched.events.len > sched.cfg.eventBufferLimit:
        let overflow = sched.events.len - sched.cfg.eventBufferLimit
        var i: int32 = 0
        while i < overflow:
            seqs.delete[comp_types.CompactionEvent](&sched.events, 0)
            i = i + 1

fn updateMetrics(sched: CompactionScheduler, result: comp_types.CompactionResult) =
    sched.metrics.totalJobs = sched.metrics.totalJobs + 1
    sched.metrics.bytesRead = sched.metrics.bytesRead + result.bytesRead
    sched.metrics.bytesWritten = sched.metrics.bytesWritten + result.bytesWritten
    let writeAmp = comp_types.WriteAmplification(result)
    sched.metrics.lastWriteAmp = writeAmp
    if writeAmp > sched.metrics.maxWriteAmp:
        sched.metrics.maxWriteAmp = writeAmp
    if sched.metrics.bytesRead > 0:
        sched.metrics.avgWriteAmp = sched.metrics.bytesWritten.float / sched.metrics.bytesRead.float
    if result.readAmp >= 0.0:
        sched.metrics.readAmpSamples.add(result.readAmp)
        if sched.metrics.readAmpSamples.len > 128:
            sched.metrics.readAmpSamples.delete(0)

fn InitCompactionScheduler(planner: comp_planner.CompactionPlanner,
                           handler: comp_types.CompactionJobHandler,
                           cfg: CompactionSchedulerConfig): CompactionScheduler =
    if planner == nil:
        raise newException(comp_types.CompactionError, "planner is nil")
    if handler == nil:
        raise newException(comp_types.CompactionError, "handler is nil")
    var sched: CompactionScheduler = new[CompactionScheduler]()
    if sched != nil:
        sched.cfg = normalizeConfig(cfg)
        sched.planner = planner
        sched.handler = handler
        sched.activeJobs = 0
        sched.pending = @[]
        sched.metrics = comp_types.CompactionMetrics()
        sched.events = @[]
        sched.planRegistry = tables.TableInit[comp_types.CompactionPlan](32)
        sched.planResults = tables.TableInit[comp_types.CompactionResult](32)
    return sched

fn runPlan(sched: CompactionScheduler,
           plan: comp_types.CompactionPlan,
           ticketOpt: option.Option[resource.ResourceTicket]) =
    if sched == nil:
        return
    let key = planKey(plan.id)
    tables.TablePut[comp_types.CompactionPlan](sched.planRegistry, key, plan)
    recordEvent(sched, comp_types.CompactionStart, plan.id,
        "plan " & uint64ToStr(plan.id) & " start", plan.strategy)
    sched.activeJobs = sched.activeJobs + 1
    try:
        let result = sched.handler(plan)
        tables.TablePut[comp_types.CompactionResult](sched.planResults, key, result)
        updateMetrics(sched, result)
        recordEvent(sched, comp_types.CompactionFinish, plan.id,
            "plan " & uint64ToStr(plan.id) & " finished",
            "bytesRead=" & int64ToStr(result.bytesRead) &
            ",bytesWritten=" & int64ToStr(result.bytesWritten))
    except CatchableError as err:
        recordEvent(sched, comp_types.CompactionFailure, plan.id,
            "plan " & uint64ToStr(plan.id) & " failed", err.msg)
        raise
    finally:
        if sched.activeJobs > 0:
            sched.activeJobs = sched.activeJobs - 1
        releaseTicket(sched, ticketOpt)

fn ScheduleNext(sched: CompactionScheduler,
                version: man_version.Version): option.Option[comp_types.CompactionPlan] =
    if sched == nil or sched.planner == nil:
        return option.none(comp_types.CompactionPlan)
    if sched.activeJobs >= sched.cfg.maxConcurrentJobs:
        return option.none(comp_types.CompactionPlan)
    if sched.pending.len > 0:
        let plan = sched.pending[0]
        let ticket = requestTicket(sched)
        if not ticket.granted:
            return option.none(comp_types.CompactionPlan)
        sched.pending.delete(0)
        runPlan(sched, plan, ticket.ticket)
        return option.some(plan)
    var telemetry = comp_types.DefaultTelemetry()
    let planOpt = comp_planner.NextPlan(sched.planner, version, telemetry)
    if not option.IsSome(planOpt):
        return option.none(comp_types.CompactionPlan)
    let plan = option.Get(planOpt)
    let ticket = requestTicket(sched)
    if not ticket.granted:
        sched.pending.add(plan)
        return option.none(comp_types.CompactionPlan)
    runPlan(sched, plan, ticket.ticket)
    return option.some(plan)

fn Metrics(sched: CompactionScheduler): comp_types.CompactionMetrics =
    if sched == nil:
        return comp_types.CompactionMetrics()
    return sched.metrics

fn Events(sched: CompactionScheduler): seq[comp_types.CompactionEvent] =
    if sched == nil:
        return @[]
    return sched.events

fn PlanResult(sched: CompactionScheduler, planId: uint64): option.Option[comp_types.CompactionResult] =
    if sched == nil:
        return option.none(comp_types.CompactionResult)
    let key = planKey(planId)
    if tables.TableHas[comp_types.CompactionResult](sched.planResults, key):
        return option.some(tables.TableGet[comp_types.CompactionResult](sched.planResults, key))
    return option.none(comp_types.CompactionResult)
