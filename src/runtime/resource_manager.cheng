module pebble_runtime_resource_manager

type
    ResourceError = CatchableError

type
    ResourceKind = enum
        ResMemoryBytes
        ResDiskBytes
        ResFileHandles
        ResCompactionTokens

type
    ResourceQuota =
        softLimit: int64
        hardLimit: int64
        inUse: int64

type
    ResourceTicket =
        kind: ResourceKind
        amount: int64

type
    ResourceManager = ref
        quotas: array[4, ResourceQuota]
        hasQuota: array[4, bool]

fn kindIndex(kind: ResourceKind): int32 =
    return int32(kind)

fn NewResourceManager(): ResourceManager =
    var rm: ResourceManager
    new rm
    if rm != nil:
        var i: int32 = 0
        while i < 4:
            rm.hasQuota[i] = false
            rm.quotas[i] = ResourceQuota(softLimit: 0, hardLimit: 0, inUse: 0)
            i = i + 1
    return rm

fn SetQuota(rm: ResourceManager, kind: ResourceKind,
            softLimit: int64, hardLimit: int64) =
    if softLimit > hardLimit:
        return
    if rm == nil:
        return
    let idx = kindIndex(kind)
    rm.quotas[idx] = ResourceQuota(softLimit: softLimit,
                                   hardLimit: hardLimit,
                                   inUse: 0)
    rm.hasQuota[idx] = true

fn AcquireQuota(rm: ResourceManager, kind: ResourceKind,
                amount: int64): ResourceTicket =
    if rm == nil:
        return ResourceTicket(kind: kind, amount: 0)
    let idx = kindIndex(kind)
    if ! rm.hasQuota[idx]:
        return ResourceTicket(kind: kind, amount: 0)
    if rm.quotas[idx].hardLimit > 0 &&
       rm.quotas[idx].inUse + amount > rm.quotas[idx].hardLimit:
        return ResourceTicket(kind: kind, amount: 0)
    rm.quotas[idx].inUse = rm.quotas[idx].inUse + amount
    return ResourceTicket(kind: kind, amount: amount)

fn Release(rm: ResourceManager, ticket: ResourceTicket) =
    if rm == nil:
        return
    let idx = kindIndex(ticket.kind)
    if ! rm.hasQuota[idx]:
        return
    rm.quotas[idx].inUse = rm.quotas[idx].inUse - ticket.amount
    if rm.quotas[idx].inUse < 0:
        rm.quotas[idx].inUse = 0

fn Utilization(rm: ResourceManager, kind: ResourceKind): float64 =
    if rm == nil:
        return 0.0
    let idx = kindIndex(kind)
    if ! rm.hasQuota[idx]:
        return 0.0
    if rm.quotas[idx].hardLimit <= 0:
        return 0.0
    return rm.quotas[idx].inUse.float / rm.quotas[idx].hardLimit.float

fn IsSoftExceeded(rm: ResourceManager, kind: ResourceKind): bool =
    if rm == nil:
        return false
    let idx = kindIndex(kind)
    if ! rm.hasQuota[idx]:
        return false
    if rm.quotas[idx].softLimit <= 0:
        return false
    return rm.quotas[idx].inUse >= rm.quotas[idx].softLimit
