module pebble_read_sources

import cheng/pebble/core/types as core_types
import cheng/pebble/mem/types as mem_types
import cheng/pebble/mem/memtable as memtable
import cheng/pebble/runtime/resource_manager as resource
import cheng/pebble/read/types as read_types
import cheng/pebble/sstable/table_reader as sstable_reader
import cheng/pebble/batch/batch as batch_module
import std/option as option
import std/tables as tables

const
    DefaultBatchPriority = -10
    DefaultMemPriority = 0
    DefaultSSTPriority = 10

fn sortRecordsDesc(records: var seq[mem_types.MemRecord]) =
    if records.len <= 1:
        return
    var i: int32 = 0
    while i < records.len:
        var j: int32 = i + 1
        while j < records.len:
            if core_types.ToUint64(records[j].seq) > core_types.ToUint64(records[i].seq):
                let tmp = records[i]
                records[i] = records[j]
                records[j] = tmp
            j = j + 1
        i = i + 1

fn reverseStrings(items: var seq[str]) =
    if items.len <= 1:
        return
    var i: int32 = 0
    var j: int32 = items.len - 1
    while i < j:
        let tmp = items[i]
        items[i] = items[j]
        items[j] = tmp
        i = i + 1
        j = j - 1

fn collectMemEntries(mt: mem_types.MemTable,
                     snapshot: core_types.SequenceNumber): seq[read_types.ReadSourceEntry] =
    if mt == nil:
        return @[]
    let snapshotValue = core_types.ToUint64(snapshot)
    var grouped = tables.TableInit[seq[mem_types.MemRecord]](64)
    var i: int32 = 0
    while i < mt.records.len:
        let rec = mt.records[i]
        if core_types.ToUint64(rec.seq) <= snapshotValue:
            let keyBytes = core_types.ToBytes(rec.key)
            var list: seq[mem_types.MemRecord]
            if tables.TableHas[seq[mem_types.MemRecord]](grouped, keyBytes):
                list = tables.TableGet[seq[mem_types.MemRecord]](grouped, keyBytes)
            list.add(rec)
            tables.TablePut[seq[mem_types.MemRecord]](grouped, keyBytes, list)
        i = i + 1
    var out: seq[read_types.ReadSourceEntry]
    var idx: int32 = 0
    var key: str = ""
    var records: seq[mem_types.MemRecord]
    while tables.TableNext[seq[mem_types.MemRecord]](grouped, &idx, &key, &records):
        if records.len == 0:
            continue
        sortRecordsDesc(records)
        let currentKey = core_types.ToKey(key)
        var currentBase = option.None[str]()
        var operands: seq[str]
        var hasVisible: bool = false
        var doneForKey: bool = false
        var j: int32 = 0
        while j < records.len:
            let rec = records[j]
            if doneForKey:
                break
            hasVisible = true
            if rec.kind == mem_types.MemValueSet:
                currentBase = option.some(rec.value)
                doneForKey = true
            elif rec.kind == mem_types.MemValueDelete:
                currentBase = option.None[str]()
                doneForKey = true
            else:
                operands.add(rec.value)
            j = j + 1
        if ! hasVisible:
            continue
        var finalValue: option.Option[str]
        if operands.len > 0:
            if ! mem_types.HasMerge(mt.cfg):
                raise read_types.ReadError(msg: "memtable merge operand without merge operator")
            reverseStrings(operands)
            finalValue = mt.cfg.mergeOperator(currentKey, currentBase, operands)
        else:
            finalValue = currentBase
        out.add(read_types.ReadSourceEntry(key: currentKey, value: finalValue))
    return out

fn MemReadSource(mt: mem_types.MemTable,
                 snapshot: core_types.SequenceNumber = core_types.ToSequence(uint64(0xFFFFFFFFFFFFFFFF)),
                 priority: int32 = DefaultMemPriority): read_types.ReadSource =
    let entries = collectMemEntries(mt, snapshot)
    return read_types.NewReadSource(entries, priority, read_types.ReadSourceMem)

fn BatchReadSource(batch: batch_module.BatchBase,
                   comparator: core_types.Comparator,
                   mergeOp: mem_types.MergeOperator = nil,
                   priority: int32 = DefaultBatchPriority): read_types.ReadSource =
    if batch == nil || batch.ops.len == 0:
        return read_types.NewReadSource(newSeq[read_types.ReadSourceEntry](), priority, read_types.ReadSourceBatch)
    var effectiveComp = comparator
    if effectiveComp == nil:
        effectiveComp = core_types.CompareBytewise
    var hasMerge: bool = false
    var i: int32 = 0
    while i < batch.ops.len:
        if batch.ops[i].kind == mem_types.MemValueMerge:
            hasMerge = true
            break
        i = i + 1
    if hasMerge && mergeOp == nil:
        raise read_types.ReadError(msg: "batch contains merge operations; merge operator required")
    var cfg: mem_types.MemTableConfig
    cfg.comparator = effectiveComp
    cfg.mergeOperator = mergeOp
    cfg.softLimitBytes = 0
    cfg.hardLimitBytes = 0
    cfg.resourceManager = nil
    cfg.resourceKind = resource.ResMemoryBytes
    cfg.flushExecutor = nil
    cfg.flushTrigger = nil
    var temp = memtable.InitMemTable(cfg)
    let applyEntries = batch_module.ToApplyEntries(batch, core_types.ToSequence(1))
    if applyEntries.len > 0:
        memtable.ApplyBatch(temp, applyEntries)
    let entries = collectMemEntries(temp, core_types.ToSequence(uint64(0xFFFFFFFFFFFFFFFF)))
    return read_types.NewReadSource(entries, priority, read_types.ReadSourceBatch)

fn SstReadSource(reader: sstable_reader.TableReader,
                 priority: int32 = DefaultSSTPriority): read_types.ReadSource =
    var entries: seq[read_types.ReadSourceEntry]
    if reader != nil:
        let scanned = sstable_reader.Scan(reader)
        var i: int32 = 0
        while i < scanned.len:
            let entry = scanned[i]
            entries.add(read_types.ReadSourceEntry(
                key: entry.key,
                value: option.some(entry.value)
            ))
            i = i + 1
    return read_types.NewReadSource(entries, priority, read_types.ReadSourceSST)

fn CustomReadSource(entries: seq[read_types.ReadSourceEntry],
                    priority: int32): read_types.ReadSource =
    return read_types.NewReadSource(entries, priority, read_types.ReadSourceCustom)
