module pebble_vfs_prefetch_rate

import cheng/pebble/vfs/types as vtypes
import std/std/monotimes as monotimes

@importc("usleep")
fn c_usleep(usec: uint32): int32

type
    RateLimiter = ref
        capacity: float64
        tokens: float64
        refillPerNs: float64
        lastRefill: monotimes.MonoTime

type
    PrefetchExecutor = ref
        enabled: bool
        maxInFlight: int32

type
    RateLimitedFileState = ref
        inner: vtypes.File
        readLimiter: RateLimiter
        writeLimiter: RateLimiter
        prefetcher: PrefetchExecutor
        asyncPrefetch: bool
        path: str

type
    RateLimitedFileSystemState = ref
        base: vtypes.FileSystem
        readLimiter: RateLimiter
        writeLimiter: RateLimiter
        prefetcher: PrefetchExecutor
        asyncPrefetch: bool

type
    PrefetchTask = ref
        limiter: RateLimiter
        file: vtypes.File
        offset: int64
        length: int64

    ScheduleRequest = ref
        executor: PrefetchExecutor
        job: fn()

fn NewRateLimiter(bytesPerSecond: float64, burst: float64 = 0.0): RateLimiter =
    if bytesPerSecond <= 0.0:
        return nil
    let burstSize = if burst <= 0.0: bytesPerSecond else: burst
    return RateLimiter(
        capacity: burstSize,
        tokens: burstSize,
        refillPerNs: bytesPerSecond / 1000000000.0,
        lastRefill: monotimes.getMonoTime()
    )

fn refill(limiter: RateLimiter) =
    if limiter == nil:
        return
    let now = monotimes.getMonoTime()
    let delta = now - limiter.lastRefill
    let nanos = float64(delta.ns)
    if nanos <= 0.0:
        return
    let added = nanos * limiter.refillPerNs
    let next = limiter.tokens + added
    limiter.tokens = if next > limiter.capacity: limiter.capacity else: next
    limiter.lastRefill = now

fn sleepForNs(nanos: int64) =
    if nanos <= 0:
        return
    var usec = nanos / 1000
    if usec <= 0:
        usec = 1
    while usec > 0:
        let step = if usec > 1000000: uint32(1000000) else: uint32(usec)
        c_usleep(step)
        usec = usec - int64(step)

fn Acquire(limiter: RateLimiter, amount: int32) =
    if limiter == nil || amount <= 0:
        return
    refill(limiter)
    let need = float64(amount)
    if limiter.tokens >= need:
        limiter.tokens = limiter.tokens - need
        return
    if limiter.refillPerNs <= 0.0:
        limiter.tokens = 0.0
        return
    let missing = need - limiter.tokens
    let waitNs = int64(missing / limiter.refillPerNs)
    sleepForNs(waitNs)
    refill(limiter)
    if limiter.tokens >= need:
        limiter.tokens = limiter.tokens - need
    else:
        limiter.tokens = 0.0

fn NewPrefetchExecutor(maxInFlight: int32 = 8, enabled: bool = true): PrefetchExecutor =
    if ! enabled:
        return PrefetchExecutor(enabled: false, maxInFlight: 0)
    let limit = if maxInFlight <= 0: 2147483647 else: maxInFlight
    return PrefetchExecutor(enabled: true, maxInFlight: limit)

fn schedule(executor: PrefetchExecutor, job: fn()) =
    if executor == nil || ! executor.enabled:
        job()
        return
    job()

fn runSchedule(req: ScheduleRequest) =
    if req == nil || req.job == nil:
        return
    schedule(req.executor, req.job)

fn runPrefetchTask(task: PrefetchTask) =
    if task == nil:
        return
    Acquire(task.limiter, int32(task.length))
    vtypes.Prefetch(task.file, task.offset, task.length)

fn wrap(state: RateLimitedFileSystemState, file: vtypes.File, path: str): vtypes.File =
    if file == nil:
        return nil
    if state.readLimiter == nil && state.writeLimiter == nil &&
        (state.prefetcher == nil || ! state.asyncPrefetch):
        return file
    let st = RateLimitedFileState(
        inner: file,
        readLimiter: state.readLimiter,
        writeLimiter: state.writeLimiter,
        prefetcher: state.prefetcher,
        asyncPrefetch: state.asyncPrefetch,
        path: path
    )
    var out: vtypes.File = new[vtypes.File]()
    out.closeFn = fn(self: vtypes.File) =
        self
        if st.inner != nil:
            vtypes.Close(st.inner)
            st.inner = nil
    out.readFn = fn(self: vtypes.File, dest: void*, size: int32): int32 =
        self
        Acquire(st.readLimiter, size)
        return vtypes.Read(st.inner, dest, size)
    out.readAtFn = fn(self: vtypes.File, dest: void*, size: int32, offset: int64): int32 =
        self
        Acquire(st.readLimiter, size)
        return vtypes.ReadAt(st.inner, dest, size, offset)
    out.writeFn = fn(self: vtypes.File, src: void*, size: int32): int32 =
        self
        Acquire(st.writeLimiter, size)
        return vtypes.Write(st.inner, src, size)
    out.writeAtFn = fn(self: vtypes.File, src: void*, size: int32, offset: int64): int32 =
        self
        Acquire(st.writeLimiter, size)
        return vtypes.WriteAt(st.inner, src, size, offset)
    out.preallocateFn = fn(self: vtypes.File, offset: int64, length: int64) =
        self
        vtypes.Preallocate(st.inner, offset, length)
    out.statFn = fn(self: vtypes.File): vtypes.FileInfo =
        self
        return vtypes.Stat(st.inner)
    out.syncFn = fn(self: vtypes.File) =
        self
        vtypes.Sync(st.inner)
    out.syncDataFn = fn(self: vtypes.File) =
        self
        vtypes.SyncData(st.inner)
    out.syncToFn = fn(self: vtypes.File, length: int64): bool =
        self
        return vtypes.SyncTo(st.inner, length)
    out.prefetchFn = fn(self: vtypes.File, offset: int64, length: int64) =
        self
        if length <= 0:
            return
        let limiter = st.readLimiter
        let innerFile = st.inner
        let reqLen = length
        let prefetchTask = PrefetchTask(
            limiter: limiter,
            file: innerFile,
            offset: offset,
            length: reqLen
        )
        let task = fn() =
            runPrefetchTask(prefetchTask)
        let req = ScheduleRequest(executor: st.prefetcher, job: task)
        runSchedule(req)
    out.fdFn = fn(self: vtypes.File): uint64 =
        self
        return vtypes.Fd(st.inner)
    out.mapFn = fn(self: vtypes.File, offset: int64, length: int32,
                    access: vtypes.MmapAccess): vtypes.MmapRegion =
        self
        return vtypes.Map(st.inner, offset, length, access)
    return out

fn NewRateLimitedFileSystem(base: vtypes.FileSystem, readBytesPerSec: float64,
                            writeBytesPerSec: float64, asyncPrefetch: bool,
                            maxPrefetchInFlight: int32): vtypes.FileSystem =
    if base == nil:
        raise newException(ValueError, "base FileSystem must not be nil")
    let state = RateLimitedFileSystemState(
        base: base,
        readLimiter: NewRateLimiter(readBytesPerSec),
        writeLimiter: NewRateLimiter(writeBytesPerSec),
        prefetcher: NewPrefetchExecutor(maxPrefetchInFlight, asyncPrefetch),
        asyncPrefetch: asyncPrefetch
    )
    var fs: vtypes.FileSystem = new[vtypes.FileSystem]()
    fs.createFn = fn(self: vtypes.FileSystem, path: str,
                      category: vtypes.DiskWriteCategory): vtypes.File =
        self
        return wrap(state, vtypes.Create(state.base, path, category), path)
    fs.linkFn = fn(self: vtypes.FileSystem, oldname: str, newname: str) =
        self
        vtypes.Link(state.base, oldname, newname)
    fs.openFn = fn(self: vtypes.FileSystem, path: str, opts: seq[vtypes.OpenOption]): vtypes.File =
        self
        return wrap(state, vtypes.Open(state.base, path, opts), path)
    fs.openReadWriteFn = fn(self: vtypes.FileSystem, path: str,
                             category: vtypes.DiskWriteCategory,
                             opts: seq[vtypes.OpenOption]): vtypes.File =
        self
        return wrap(state, vtypes.OpenReadWrite(state.base, path, category, opts), path)
    fs.openDirFn = fn(self: vtypes.FileSystem, path: str): vtypes.File =
        self
        return vtypes.OpenDir(state.base, path)
    fs.removeFn = fn(self: vtypes.FileSystem, path: str) =
        self
        vtypes.Remove(state.base, path)
    fs.removeAllFn = fn(self: vtypes.FileSystem, path: str) =
        self
        vtypes.RemoveAll(state.base, path)
    fs.renameFn = fn(self: vtypes.FileSystem, oldname: str, newname: str) =
        self
        vtypes.Rename(state.base, oldname, newname)
    fs.reuseForWriteFn = fn(self: vtypes.FileSystem, oldname: str, newname: str,
                             category: vtypes.DiskWriteCategory): vtypes.File =
        self
        return wrap(state, vtypes.ReuseForWrite(state.base, oldname, newname, category), newname)
    fs.mkdirAllFn = fn(self: vtypes.FileSystem, path: str, perm: uint32) =
        self
        vtypes.MkdirAll(state.base, path, perm)
    fs.lockFn = fn(self: vtypes.FileSystem, path: str): vtypes.File =
        self
        return vtypes.Lock(state.base, path)
    fs.listFn = fn(self: vtypes.FileSystem, path: str): seq[str] =
        self
        return vtypes.List(state.base, path)
    fs.statFn = fn(self: vtypes.FileSystem, path: str): vtypes.FileInfo =
        self
        return vtypes.StatPath(state.base, path)
    fs.pathBaseFn = fn(self: vtypes.FileSystem, path: str): str =
        self
        return vtypes.PathBase(state.base, path)
    fs.pathJoinFn = fn(self: vtypes.FileSystem, parts: seq[str]): str =
        self
        return vtypes.PathJoin(state.base, parts)
    fs.pathDirFn = fn(self: vtypes.FileSystem, path: str): str =
        self
        return vtypes.PathDir(state.base, path)
    fs.diskUsageFn = fn(self: vtypes.FileSystem, path: str): vtypes.DiskUsage =
        self
        return vtypes.DiskUsage(state.base, path)
    fs.unwrapFn = fn(self: vtypes.FileSystem): vtypes.FileSystem =
        self
        return state.base
    return fs
