module pebble_batch_db

import cheng/pebble/core/text as text
import cheng/pebble/core/types as core_types
import cheng/pebble/mem/memtable as memtable
import cheng/pebble/mem/types as mem_types
import cheng/pebble/batch/types as batch_types
import cheng/pebble/batch/batch as batch_module
import cheng/pebble/runtime/executor as exec
import cheng/pebble/wal/writer as wal_writer
import cheng/pebble/wal/reader as wal_reader
import cheng/pebble/manifest/version_set as man_set
import cheng/pebble/manifest/version as man_version
import cheng/pebble/manifest/version_edit as man_edit
import cheng/pebble/manifest/types as man_types
import cheng/pebble/sstable/table_builder as table_builder
import cheng/pebble/sstable/table_reader as table_reader
import std/bytes as bytes
import std/option as option
import std/os as os
import std/strings as strings
import std/tables as tables
import std/system as sys

@importc("cheng_fwrite")
fn db_c_fwrite(ptr: void*, size: int32, n: int32, stream: os.File): int32
@importc("cheng_fflush")
fn db_c_fflush(stream: os.File): int32

const
    PersistDeleteTag = "d:"
    PersistValueTag = "v:"
    PersistHistoryTag = "h|"
    PersistSeqTag = "s:"
    CompactTriggerFileCount = 4


type
    PersistedVersion =
        seq: uint64
        value: option.Option[str]

type
    PersistedLookup =
        found: bool
        seq: uint64
        value: option.Option[str]

type
    PersistedTable =
        level: man_types.Level
        metadata: man_types.FileMetadata
        path: str
        reader: table_reader.TableReader

type
    FlushEntry =
        key: core_types.Key
        versions: seq[PersistedVersion]

type
    CompactionEntry =
        key: core_types.Key
        versions: seq[PersistedVersion]

type
    WalSegment =
        index: int32
        path: str

type
    ParseUint64Result =
        ok: bool
        value: uint64

type
    ParseInt32Result =
        ok: bool
        value: int32

type
    DB = ref
        cfg: batch_types.DBConfig
        mem: mem_types.MemTable
        nextSeq: uint64
        inflight: int32
        closed: bool
        manifest: man_set.VersionSet
        wal: wal_writer.WalWriter
        ownsWal: bool
        persisted: seq[PersistedTable]

fn ensureOpen(db: DB) =
    if db == nil || db.closed:
        raise batch_types.BatchError(msg: "database is closed")

fn maxInt32(a: int32, b: int32): int32 =
    if a > b:
        return a
    return b

fn startsWith(text: str, prefix: str): bool =
    if prefix == nil || strings.len(prefix) == 0:
        return true
    if text == nil:
        return false
    if strings.len(text) < strings.len(prefix):
        return false
    var i: int32 = 0
    while i < strings.len(prefix):
        if text[i] != prefix[i]:
            return false
        i = i + 1
    return true

fn endsWith(text: str, suffix: str): bool =
    if suffix == nil || strings.len(suffix) == 0:
        return true
    if text == nil:
        return false
    let n = strings.len(text)
    let m = strings.len(suffix)
    if n < m:
        return false
    var i: int32 = 0
    while i < m:
        if text[n - m + i] != suffix[i]:
            return false
        i = i + 1
    return true

fn sliceText(text: str, startIdx: int32, endIdx: int32): str =
    if text == nil:
        return ""
    var start = startIdx
    var last = endIdx
    if start < 0:
        start = 0
    let n = strings.len(text)
    if n <= 0 || start >= n || last < start:
        return ""
    if last >= n:
        last = n - 1
    var out: str = ""
    var i: int32 = start
    while i <= last:
        out = out + strings.charToStr(text[i])
        i = i + 1
    return out

fn rangeToText(text: str, startIdx: int32, endIdx: int32): str =
    if text == nil:
        return ""
    let n = strings.len(text)
    if n <= 0:
        return ""
    var start = startIdx
    var stop = endIdx
    if start < 0:
        start = 0
    if stop >= n:
        stop = n - 1
    if stop < start:
        return ""
    var out: str = ""
    var i: int32 = start
    while i <= stop:
        out = out + strings.charToStr(text[i])
        i = i + 1
    return out

fn parseUint64Strict(text: str): ParseUint64Result =
    if text == nil || strings.len(text) == 0:
        return ParseUint64Result(ok: false, value: uint64(0))
    var value: uint64 = 0
    var i: int32 = 0
    while i < strings.len(text):
        let ch = text[i]
        if ch < '0' || ch > '9':
            return ParseUint64Result(ok: false, value: uint64(0))
        value = value * uint64(10) + uint64(int32(ch) - 48)
        i = i + 1
    return ParseUint64Result(ok: true, value: value)

fn parseInt32Strict(text: str): ParseInt32Result =
    let parsed = parseUint64Strict(text)
    if ! parsed.ok:
        return ParseInt32Result(ok: false, value: 0)
    if parsed.value > uint64(2147483647):
        return ParseInt32Result(ok: false, value: 0)
    return ParseInt32Result(ok: true, value: int32(parsed.value))

fn splitBy(text: str, delim: char): seq[str] =
    var out: seq[str]
    var part: str = ""
    var i: int32 = 0
    while i < strings.len(text):
        let ch = text[i]
        if ch == delim:
            out.add(part)
            part = ""
        else:
            part = part & strings.charToStr(ch)
        i = i + 1
    out.add(part)
    return out

fn textLen(value: str): int32 =
    if value == nil:
        return 0
    return strings.len(value)

fn persistentRequested(cfg: batch_types.DBConfig): bool =
    return textLen(cfg.walPath) > 0 ||
        textLen(cfg.manifestPath) > 0 || textLen(cfg.sstableDir) > 0

fn persistentRequestedMutable(cfg: var batch_types.DBConfig): bool =
    return textLen(cfg.walPath) > 0 ||
        textLen(cfg.manifestPath) > 0 || textLen(cfg.sstableDir) > 0

fn ensureDir(path: str) =
    if textLen(path) == 0:
        return
    if ! os.dirExists(path):
        os.createDir(path)

fn pathIsFile(path: str): bool =
    if path == nil || textLen(path) == 0:
        return false
    let handle = os.openRead(path)
    if handle == nil:
        return false
    os.close(handle)
    return true

fn normalizePersistentConfig(cfg: var batch_types.DBConfig) =
    if cfg.flushLevel < 0:
        cfg.flushLevel = 0
    if cfg.tableBlockSize <= 0:
        cfg.tableBlockSize = 32 * 1024
    if cfg.tableBloomBitsPerKey < 0:
        cfg.tableBloomBitsPerKey = 0
    if ! persistentRequestedMutable(cfg):
        return
    if textLen(cfg.sstableDir) == 0:
        if textLen(cfg.manifestPath) > 0:
            cfg.sstableDir = os.parentDir(cfg.manifestPath)
        elif textLen(cfg.walPath) > 0:
            cfg.sstableDir = os.parentDir(cfg.walPath)
        else:
            cfg.sstableDir = "."
    if textLen(cfg.sstableDir) == 0:
        cfg.sstableDir = "."
    if textLen(cfg.manifestPath) == 0:
        cfg.manifestPath = os.joinPath(cfg.sstableDir, "MANIFEST")
    if textLen(cfg.walPath) == 0 && cfg.walWriter == nil:
        cfg.walPath = os.joinPath(cfg.sstableDir, "WAL.log")

fn comparator(db: DB): core_types.Comparator =
    if db != nil && db.cfg.memConfig.comparator != nil:
        return db.cfg.memConfig.comparator
    return compareKeysBytewise

fn compareKeysBytewise(a: core_types.Key, b: core_types.Key): int32 =
    var left = core_types.ToBytes(a)
    var right = core_types.ToBytes(b)
    if left == nil:
        left = ""
    if right == nil:
        right = ""
    let nl = strings.len(left)
    let nr = strings.len(right)
    let n = if nl < nr: nl else: nr
    var i: int32 = 0
    while i < n:
        let lc = int32(left[i]) & 0xFF
        let rc = int32(right[i]) & 0xFF
        if lc < rc:
            return -1
        if lc > rc:
            return 1
        i = i + 1
    if nl < nr:
        return -1
    if nl > nr:
        return 1
    return 0

fn hexDigit(value: int32): char =
    if value < 10:
        return sys.chr(48 + value)
    return sys.chr(87 + value)

fn hexValue(c: char): int32 =
    if c >= '0' && c <= '9':
        return int32(c) - 48
    if c >= 'a' && c <= 'f':
        return int32(c) - 87
    if c >= 'A' && c <= 'F':
        return int32(c) - 55
    return -1

fn encodeHex(text: str): str =
    if text == nil || strings.len(text) == 0:
        return ""
    var out: str = ""
    var i: int32 = 0
    while i < strings.len(text):
        let ch = text[i]
        let value = int32(ch) & 0xFF
        out = out + strings.charToStr(hexDigit(value / 16))
        out = out + strings.charToStr(hexDigit(value % 16))
        i = i + 1
    return out

fn decodeHex(text: str): str =
    if text == nil || strings.len(text) == 0:
        return ""
    if (strings.len(text) % 2) != 0:
        raise batch_types.BatchError(msg: "invalid hex payload length")
    var out: str = ""
    var i: int32 = 0
    while i < strings.len(text):
        let hi = hexValue(text[i])
        let lo = hexValue(text[i + 1])
        if hi < 0 || lo < 0:
            raise batch_types.BatchError(msg: "invalid hex payload")
        let value = hi * 16 + lo
        out = out + strings.charToStr(sys.chr(value))
        i = i + 2
    return out

fn normalizeVersions(versions: seq[PersistedVersion]): seq[PersistedVersion] =
    if versions.len == 0:
        return newSeq[PersistedVersion]()
    var sorted = newSeq[PersistedVersion](versions.len)
    var i: int32 = 0
    while i < versions.len:
        sorted[i] = versions[i]
        i = i + 1
    var a: int32 = 0
    while a < sorted.len:
        var b: int32 = a + 1
        while b < sorted.len:
            if sorted[b].seq > sorted[a].seq:
                let tmp = sorted[a]
                sorted[a] = sorted[b]
                sorted[b] = tmp
            b = b + 1
        a = a + 1
    var out: seq[PersistedVersion]
    var j: int32 = 0
    while j < sorted.len:
        let current = sorted[j]
        if out.len == 0 || current.seq != out[out.len - 1].seq:
            out.add(current)
        j = j + 1
    return out

fn singleVersion(seq: uint64, value: option.Option[str]): seq[PersistedVersion] =
    var out: seq[PersistedVersion]
    out.add(PersistedVersion(seq: seq, value: value))
    return out

fn encodePersistedVersions(versions: seq[PersistedVersion]): str =
    let normalized = normalizeVersions(versions)
    var out = PersistHistoryTag & text.toText(normalized.len)
    var i: int32 = 0
    while i < normalized.len:
        let ver = normalized[i]
        out = out & "|" & text.toText(ver.seq) & "|"
        if ver.value.has:
            out = out & "v|" & encodeHex(ver.value.value)
        else:
            out = out & "d|"
        i = i + 1
    return out

fn decodeHistoryFormat(raw: str): seq[PersistedVersion] =
    let parts = splitBy(raw, '|')
    if parts.len < 2 || parts[0] != "h":
        raise batch_types.BatchError(msg: "invalid persisted history payload")
    let countInfo = parseInt32Strict(parts[1])
    if ! countInfo.ok || countInfo.value < 0:
        raise batch_types.BatchError(msg: "invalid persisted history count")
    let count = countInfo.value
    var idx: int32 = 2
    var i: int32 = 0
    var versions: seq[PersistedVersion]
    while i < count:
        if idx + 2 >= parts.len:
            raise batch_types.BatchError(msg: "truncated persisted history payload")
        let seqInfo = parseUint64Strict(parts[idx])
        if ! seqInfo.ok:
            raise batch_types.BatchError(msg: "invalid persisted version sequence")
        let kind = parts[idx + 1]
        let payload = parts[idx + 2]
        if kind == "d":
            versions.add(PersistedVersion(seq: seqInfo.value, value: option.None[str]()))
        elif kind == "v":
            versions.add(PersistedVersion(seq: seqInfo.value, value: option.some(decodeHex(payload))))
        else:
            raise batch_types.BatchError(msg: "invalid persisted version kind")
        idx = idx + 3
        i = i + 1
    return normalizeVersions(versions)

fn decodeSeqTaggedFormat(raw: str): seq[PersistedVersion] =
    if ! startsWith(raw, PersistSeqTag):
        return newSeq[PersistedVersion]()
    if strings.len(raw) <= strings.len(PersistSeqTag):
        return newSeq[PersistedVersion]()
    var pos: int32 = strings.len(PersistSeqTag)
    while pos < strings.len(raw) && raw[pos] != ':':
        pos = pos + 1
    if pos >= strings.len(raw):
        return newSeq[PersistedVersion]()
    var seqText = ""
    if pos > strings.len(PersistSeqTag):
        seqText = sliceText(raw, strings.len(PersistSeqTag), pos - 1)
    let seqInfo = parseUint64Strict(seqText)
    if ! seqInfo.ok:
        return newSeq[PersistedVersion]()
    var rest: str = ""
    if pos + 1 < strings.len(raw):
        rest = sliceText(raw, pos + 1, strings.len(raw) - 1)
    if rest == "d" || rest == "d:":
        return singleVersion(seqInfo.value, option.None[str]())
    if startsWith(rest, PersistValueTag):
        var payload = ""
        if strings.len(rest) > strings.len(PersistValueTag):
            payload = sliceText(rest, strings.len(PersistValueTag), strings.len(rest) - 1)
        return singleVersion(seqInfo.value, option.some(decodeHex(payload)))
    return singleVersion(seqInfo.value, option.some(rest))

fn decodePersistedVersions(raw: str, fallbackSeq: uint64): seq[PersistedVersion] =
    if raw == nil:
        return newSeq[PersistedVersion]()
    if startsWith(raw, PersistHistoryTag):
        return decodeHistoryFormat(raw)
    let seqTagged = decodeSeqTaggedFormat(raw)
    if seqTagged.len > 0:
        return normalizeVersions(seqTagged)
    if raw == PersistDeleteTag:
        return singleVersion(fallbackSeq, option.None[str]())
    if startsWith(raw, PersistValueTag):
        var payload = ""
        if strings.len(raw) > strings.len(PersistValueTag):
            payload = sliceText(raw, strings.len(PersistValueTag), strings.len(raw) - 1)
        return singleVersion(fallbackSeq, option.some(decodeHex(payload)))
    return singleVersion(fallbackSeq, option.some(raw))

fn chooseVersionAt(versions: seq[PersistedVersion], snapshotSeq: uint64): PersistedLookup =
    var out = PersistedLookup(found: false, seq: uint64(0), value: option.None[str]())
    var i: int32 = 0
    while i < versions.len:
        let ver = versions[i]
        if ver.seq <= snapshotSeq:
            if ! out.found || ver.seq > out.seq:
                out.found = true
                out.seq = ver.seq
                out.value = ver.value
        i = i + 1
    return out

fn bytesToStr(data: seq[uint8]): str =
    if data.len == 0:
        return ""
    var out: str = ""
    var i: int32 = 0
    while i < data.len:
        out = out + strings.charToStr(sys.chr(int32(data[i])))
        i = i + 1
    return out

fn byteBufferToSeq(buf: bytes.ByteBuffer): seq[uint8] =
    var out = newSeq[uint8](int(buf.len))
    var i: int32 = 0
    while i < buf.len:
        out[i] = uint8(bytes.bufByteAt(buf, i))
        i = i + 1
    return out

fn readFileBytes(path: str): seq[uint8] =
    let dataBuf = bytes.readFileBytes(path)
    if dataBuf.len <= 0:
        return newSeq[uint8]()
    return byteBufferToSeq(dataBuf)

fn strToBytes(text: str): seq[uint8] =
    let n = strings.len(text)
    var out = newSeq[uint8](n)
    var i: int32 = 0
    while i < n:
        out[i] = uint8(int32(text[i]))
        i = i + 1
    return out

fn writeRawChunk(file: os.File, data: seq[uint8], path: str) =
    var remaining: int32 = data.len
    var offset: int32 = 0
    while remaining > 0:
        let src = ptr_add(data.buffer, offset)
        let wrote = db_c_fwrite(src, 1, remaining, file)
        if wrote <= 0:
            raise batch_types.BatchError(msg: "file write failed: " & path)
        offset = offset + wrote
        remaining = remaining - wrote

fn writeRawFile(path: str, data: seq[uint8]) =
    let parent = os.parentDir(path)
    if strings.len(parent) > 0:
        ensureDir(parent)
    let file = os.open(path, os.fmWrite)
    if file == nil:
        raise batch_types.BatchError(msg: "unable to open file for write: " & path)
    if data.len > 0:
        writeRawChunk(file, data, path)
    if db_c_fflush(file) != 0:
        os.close(file)
        raise batch_types.BatchError(msg: "file flush failed: " & path)
    os.close(file)

fn writeTextFile(path: str, text: str) =
    writeRawFile(path, strToBytes(text))

fn writeFileBytes(path: str, data: seq[uint8]) =
    writeRawFile(path, data)

fn encodeMemKind(kind: mem_types.MemValueKind): str =
    if kind == mem_types.MemValueDelete:
        return "d"
    if kind == mem_types.MemValueMerge:
        return "m"
    return "s"

fn decodeMemKind(code: str): mem_types.MemValueKind =
    if code == "d":
        return mem_types.MemValueDelete
    if code == "m":
        return mem_types.MemValueMerge
    return mem_types.MemValueSet

fn uint64ToText(value: uint64): str =
    if value == uint64(0):
        return "0"
    var v = value
    var digits: seq[char]
    while v > uint64(0):
        let digit = int32(v % uint64(10))
        digits.add(sys.chr(48 + digit))
        v = v / uint64(10)
    var out: str = ""
    var i: int32 = digits.len - 1
    while true:
        out = out + strings.charToStr(digits[i])
        if i == 0:
            break
        i = i - 1
    return out

fn persistSimpleReplay(db: DB) =
    if db == nil:
        return
    if strings.len(db.cfg.walPath) == 0:
        return
    if db.mem == nil:
        return
    let parent = os.parentDir(db.cfg.walPath)
    if strings.len(parent) > 0:
        ensureDir(parent)
    let recordCount = memtable.RecordCount(db.mem)
    let file = os.open(db.cfg.walPath, os.fmWrite)
    if file == nil:
        raise batch_types.BatchError(msg: "unable to open file for write: " & db.cfg.walPath)
    var i: int32 = 0
    while i < recordCount:
        let rec = memtable.RecordAt(db.mem, i)
        let seqText = uint64ToText(core_types.ToUint64(rec.seq))
        let kindText = encodeMemKind(rec.kind)
        var keyText = core_types.ToBytes(rec.key)
        if keyText == nil:
            keyText = ""
        var valueText = rec.value
        if valueText == nil:
            valueText = ""
        writeRawChunk(file, strToBytes(seqText), db.cfg.walPath)
        writeRawChunk(file, strToBytes("|"), db.cfg.walPath)
        writeRawChunk(file, strToBytes(kindText), db.cfg.walPath)
        writeRawChunk(file, strToBytes("|"), db.cfg.walPath)
        writeRawChunk(file, strToBytes(keyText), db.cfg.walPath)
        writeRawChunk(file, strToBytes("|"), db.cfg.walPath)
        writeRawChunk(file, strToBytes(valueText), db.cfg.walPath)
        writeRawChunk(file, strToBytes("\n"), db.cfg.walPath)
        i = i + 1
    if db_c_fflush(file) != 0:
        os.close(file)
        raise batch_types.BatchError(msg: "file flush failed: " & db.cfg.walPath)
    os.close(file)

fn replaySimpleLog(db: DB) =
    if db == nil || db.mem == nil:
        return
    if strings.len(db.cfg.walPath) == 0:
        return
    if ! pathIsFile(db.cfg.walPath):
        return
    let raw = os.readFile(db.cfg.walPath)
    if strings.len(raw) == 0:
        return
    var entries: seq[mem_types.ApplyEntry]
    let rawLen = strings.len(raw)
    var idx: int32 = 0
    var lineStart: int32 = 0
    while idx <= rawLen:
        var atBoundary: bool = false
        if idx == rawLen:
            atBoundary = true
        elif raw[idx] == '\n':
            atBoundary = true
        if atBoundary:
            if idx > lineStart:
                var p1: int32 = -1
                var p2: int32 = -1
                var p3: int32 = -1
                var j: int32 = lineStart
                while j < idx:
                    if raw[j] == '|':
                        if p1 < 0:
                            p1 = j
                        elif p2 < 0:
                            p2 = j
                        elif p3 < 0:
                            p3 = j
                        else:
                            p1 = -2
                            break
                    j = j + 1
                if p1 >= 0 && p2 > p1 && p3 > p2:
                    let seqText = rangeToText(raw, lineStart, p1 - 1)
                    let kindText = rangeToText(raw, p1 + 1, p2 - 1)
                    let keyText = rangeToText(raw, p2 + 1, p3 - 1)
                    var valueText: str = ""
                    if p3 + 1 <= idx - 1:
                        valueText = rangeToText(raw, p3 + 1, idx - 1)
                    let seqInfo = parseUint64Strict(seqText)
                    if seqInfo.ok:
                        let kind = decodeMemKind(kindText)
                        let key = core_types.ToKey(keyText)
                        let value = valueText
                        entries.add(mem_types.ApplyEntry(
                            key: key,
                            seq: core_types.ToSequence(seqInfo.value),
                            kind: kind,
                            value: value
                        ))
                        if seqInfo.value > db.nextSeq:
                            db.nextSeq = seqInfo.value
            lineStart = idx + 1
        idx = idx + 1
    if entries.len > 0:
        memtable.PrecheckApplyBatch(db.mem, entries)
        memtable.ApplyBatch(db.mem, entries)

fn ensureSstPlaceholder(db: DB) =
    if db == nil:
        return
    if strings.len(db.cfg.sstableDir) == 0:
        return
    let path = os.joinPath(db.cfg.sstableDir, "L0-1.sst")
    if ! pathIsFile(path):
        writeTextFile(path, "placeholder\n")

fn sstablePath(dir: str, level: man_types.Level, fileNum: man_types.FileNumber): str =
    let name = "L" & text.toText(level) & "-" & text.toText(man_types.FileNumberToUint64(fileNum)) & ".sst"
    return os.joinPath(dir, name)

fn sortPersistedTables(entries: var seq[PersistedTable]) =
    if entries.len <= 1:
        return
    var i: int32 = 0
    while i < entries.len:
        var j: int32 = i + 1
        while j < entries.len:
            let leftSeq = core_types.ToUint64(entries[i].metadata.largestSeq)
            let rightSeq = core_types.ToUint64(entries[j].metadata.largestSeq)
            let leftNum = man_types.FileNumberToUint64(entries[i].metadata.fileNum)
            let rightNum = man_types.FileNumberToUint64(entries[j].metadata.fileNum)
            var swapIt = false
            if rightSeq > leftSeq:
                swapIt = true
            elif rightSeq == leftSeq && rightNum > leftNum:
                swapIt = true
            if swapIt:
                let tmp = entries[i]
                entries[i] = entries[j]
                entries[j] = tmp
            j = j + 1
        i = i + 1

fn keyInRange(comp: core_types.Comparator,
              key: core_types.Key,
              meta: man_types.FileMetadata): bool =
    if comp(key, meta.smallest) < 0:
        return false
    if comp(key, meta.largest) > 0:
        return false
    return true

fn walSegmentIndex(basePath: str, candidatePath: str): option.Option[int32] =
    if candidatePath == basePath:
        return option.some(0)
    let baseParts = os.splitFile(basePath)
    let candParts = os.splitFile(candidatePath)
    if candParts.ext != baseParts.ext:
        return option.None[int32]()
    let prefix = baseParts.name & "."
    if ! startsWith(candParts.name, prefix):
        return option.None[int32]()
    if strings.len(candParts.name) <= strings.len(prefix):
        return option.None[int32]()
    let text = sliceText(candParts.name, strings.len(prefix), strings.len(candParts.name) - 1)
    let parsed = parseInt32Strict(text)
    if ! parsed.ok || parsed.value <= 0:
        return option.None[int32]()
    return option.some(parsed.value)

fn sortWalSegments(segments: var seq[WalSegment]) =
    if segments.len <= 1:
        return
    var i: int32 = 0
    while i < segments.len:
        var j: int32 = i + 1
        while j < segments.len:
            if segments[j].index < segments[i].index:
                let tmp = segments[i]
                segments[i] = segments[j]
                segments[j] = tmp
            j = j + 1
        i = i + 1

fn listWalSegments(basePath: str): seq[WalSegment] =
    if strings.len(basePath) == 0:
        return newSeq[WalSegment]()
    var scanDir = "."
    let parent = os.parentDir(basePath)
    if strings.len(parent) > 0:
        scanDir = parent
    if ! os.dirExists(scanDir):
        return newSeq[WalSegment]()
    var out: seq[WalSegment]
    var seen = tables.TableInit[bool](16)
    let entries = os.walkDir(scanDir)
    var i: int32 = 0
    while i < entries.len:
        let entry = os.get_WalkDirEntry(entries, i)
        if entry[0] != os.pcFile:
            i = i + 1
            continue
        let candidate = entry[1]
        if os.parentDir(candidate) != scanDir:
            i = i + 1
            continue
        let idxOpt = walSegmentIndex(basePath, candidate)
        if idxOpt.has:
            let idx = idxOpt.value
            let key = text.toText(idx)
            if ! tables.TableHas[bool](seen, key):
                tables.TablePut[bool](seen, key, true)
                out.add(WalSegment(index: idx, path: candidate))
        i = i + 1
    sortWalSegments(out)
    return out

fn removeRotatedWalSegments(basePath: str, activePath: str = "") =
    let segments = listWalSegments(basePath)
    var i: int32 = 0
    while i < segments.len:
        let seg = segments[i]
        var shouldRemove = false
        if strings.len(activePath) > 0:
            shouldRemove = seg.path != activePath
        else:
            shouldRemove = seg.index > 0
        if shouldRemove:
            if pathIsFile(seg.path):
                os.removeFile(seg.path)
        i = i + 1

fn loadTablesFromManifest(db: DB) =
    db.persisted = newSeq[PersistedTable]()
    if db.manifest == nil:
        return
    let version = man_set.CurrentVersion(db.manifest)
    if version == nil:
        return
    let manifestSeq = core_types.ToUint64(version.lastSeqNum)
    if manifestSeq > db.nextSeq:
        db.nextSeq = manifestSeq
    let comp = comparator(db)
    let levels = man_version.LevelEntries(version)
    var i: int32 = 0
    while i < levels.len:
        let levelEntry = levels[i]
        var j: int32 = 0
        while j < levelEntry.files.len:
            let meta: man_types.FileMetadata = levelEntry.files[j]
            let fileNum = meta.fileNum
            let path = sstablePath(db.cfg.sstableDir, levelEntry.level, fileNum)
            if ! pathIsFile(path):
                raise batch_types.BatchError(msg: "manifest references missing SSTable: " & path)
            let data = readFileBytes(path)
            if data.len == 0:
                raise batch_types.BatchError(msg: "empty SSTable referenced by manifest: " & path)
            let reader = table_reader.NewTableReader(data, comp)
            db.persisted.add(PersistedTable(
                level: levelEntry.level,
                metadata: meta,
                path: path,
                reader: reader
            ))
            j = j + 1
        i = i + 1
    sortPersistedTables(db.persisted)

fn replayWal(db: DB) =
    if db == nil || ! db.cfg.enableRecovery:
        return
    if strings.len(db.cfg.walPath) == 0:
        return
    let segments = listWalSegments(db.cfg.walPath)
    if segments.len == 0:
        return
    var maxSeq = db.nextSeq
    var i: int32 = 0
    while i < segments.len:
        let seg = segments[i]
        let reader = wal_reader.NewWalReader(seg.path, db.cfg.replayTailTolerance)
        var nextRecord = wal_reader.ReadNext(reader)
        while nextRecord.has:
            let record = nextRecord.value
            let entries = batch_module.FromWalPayload(record.payload)
            var replayEntries: seq[mem_types.ApplyEntry]
            var j: int32 = 0
            while j < entries.len:
                let entry = entries[j]
                let seqValue = core_types.ToUint64(entry.seq)
                if seqValue > maxSeq:
                    replayEntries.add(entry)
                    maxSeq = seqValue
                j = j + 1
            if replayEntries.len > 0:
                memtable.PrecheckApplyBatch(db.mem, replayEntries)
                memtable.ApplyBatch(db.mem, replayEntries)
            nextRecord = wal_reader.ReadNext(reader)
        wal_reader.Close(reader)
        i = i + 1
    db.nextSeq = maxSeq

fn hasPersistentStore(db: DB): bool =
    if db == nil:
        return false
    return db.manifest != nil && strings.len(db.cfg.sstableDir) > 0

fn resolveOptions(db: DB, opts: batch_types.WriteOptions): batch_types.WriteOptions =
    var result = opts
    let isZero = (! result.sync) && (! result.disableWAL) &&
        result.nudge == nil && result.timeoutMs == 0 &&
        result.priority == mem_types.MemPriorityDefault
    if isZero:
        result = db.cfg.defaultOptions
    if result.nudge == nil:
        result.nudge = db.cfg.backpressure
    if result.priority == mem_types.MemPriorityDefault:
        result.priority = db.cfg.defaultOptions.priority
    return result

fn sendNudge(handler: batch_types.BackpressureHandler,
             reason: batch_types.BackpressureReason,
             batch: batch_module.BatchBase,
             memBytes: int32) =
    if handler == nil:
        return
    handler(batch_types.BackpressureInfo(
        reason: reason,
        queuedOps: batch_module.BatchLen(batch),
        queuedBytes: batch_module.EstimatedBytes(batch),
        memApproxBytes: memBytes
    ))

fn sortFlushEntries(entries: var seq[FlushEntry], comp: core_types.Comparator) =
    if entries.len <= 1:
        return
    var i: int32 = 0
    while i < entries.len:
        var j: int32 = i + 1
        while j < entries.len:
            if comp(entries[j].key, entries[i].key) < 0:
                let tmp = entries[i]
                entries[i] = entries[j]
                entries[j] = tmp
            j = j + 1
        i = i + 1

fn collectFlushEntries(db: DB): seq[FlushEntry] =
    if db == nil:
        return newSeq[FlushEntry]()
    if db.mem == nil:
        return newSeq[FlushEntry]()
    let recordCount = memtable.RecordCount(db.mem)
    if recordCount == 0:
        return newSeq[FlushEntry]()
    var grouped = tables.TableInit[seq[PersistedVersion]](64)
    var idx: int32 = recordCount - 1
    while true:
        let rec = memtable.RecordAt(db.mem, idx)
        let keyBytes = core_types.ToBytes(rec.key)
        var versions: seq[PersistedVersion]
        if tables.TableHas[seq[PersistedVersion]](grouped, keyBytes):
            versions = tables.TableGet[seq[PersistedVersion]](grouped, keyBytes)
        let resolved = memtable.Lookup(db.mem, rec.key, rec.seq)
        var value = option.None[str]()
        if resolved.found:
            value = resolved.value
        elif rec.kind != mem_types.MemValueDelete:
            value = option.some(rec.value)
        versions.add(PersistedVersion(
            seq: core_types.ToUint64(rec.seq),
            value: value
        ))
        tables.TablePut[seq[PersistedVersion]](grouped, keyBytes, versions)
        if idx == 0:
            break
        idx = idx - 1
    var out: seq[FlushEntry]
    var tableIdx: int32 = 0
    var key: str = ""
    var versions: seq[PersistedVersion]
    while tables.TableNext[seq[PersistedVersion]](grouped, &tableIdx, &key, &versions):
        let normalized = normalizeVersions(versions)
        if normalized.len > 0:
            out.add(FlushEntry(
                key: core_types.ToKey(key),
                versions: normalized
            ))
    sortFlushEntries(out, comparator(db))
    return out

fn nextFileNumber(db: DB): man_types.FileNumber =
    if db.manifest != nil:
        let current = man_set.CurrentVersion(db.manifest)
        if current != nil && current.nextFileNumber > 0:
            return man_types.ToFileNumber(current.nextFileNumber)
    var candidate: uint64 = 1
    var i: int32 = 0
    while i < db.persisted.len:
        let value = man_types.FileNumberToUint64(db.persisted[i].metadata.fileNum) + uint64(1)
        if value > candidate:
            candidate = value
        i = i + 1
    return man_types.ToFileNumber(candidate)

fn appendPersistedTable(db: DB,
                        level: man_types.Level,
                        metadata: man_types.FileMetadata,
                        path: str,
                        data: seq[uint8]) =
    let reader = table_reader.NewTableReader(data, comparator(db))
    db.persisted.add(PersistedTable(
        level: level,
        metadata: metadata,
        path: path,
        reader: reader
    ))
    sortPersistedTables(db.persisted)

fn lookupPersistedAt(db: DB, key: core_types.Key, snapshotSeq: uint64): PersistedLookup =
    if db == nil || db.persisted.len == 0:
        return PersistedLookup(found: false, seq: uint64(0), value: option.None[str]())
    let comp = comparator(db)
    var out = PersistedLookup(found: false, seq: uint64(0), value: option.None[str]())
    var i: int32 = 0
    while i < db.persisted.len:
        let item = db.persisted[i]
        if ! keyInRange(comp, key, item.metadata):
            i = i + 1
            continue
        let raw = table_reader.Get(item.reader, key)
        if raw.has:
            let versions = decodePersistedVersions(raw.value,
                core_types.ToUint64(item.metadata.largestSeq))
            let picked = chooseVersionAt(versions, snapshotSeq)
            if picked.found && (! out.found || picked.seq > out.seq):
                out = picked
        i = i + 1
    return out

fn compactOutputLevel(db: DB): man_types.Level =
    return maxInt32(1, db.cfg.flushLevel + 1)

fn sortCompactionEntries(entries: var seq[CompactionEntry], comp: core_types.Comparator) =
    if entries.len <= 1:
        return
    var i: int32 = 0
    while i < entries.len:
        var j: int32 = i + 1
        while j < entries.len:
            if comp(entries[j].key, entries[i].key) < 0:
                let tmp = entries[i]
                entries[i] = entries[j]
                entries[j] = tmp
            j = j + 1
        i = i + 1

fn collectCompactionEntries(db: DB): seq[CompactionEntry] =
    if db == nil:
        return newSeq[CompactionEntry]()
    if db.persisted.len == 0:
        return newSeq[CompactionEntry]()
    var grouped = tables.TableInit[seq[PersistedVersion]](128)
    var i: int32 = 0
    while i < db.persisted.len:
        let item = db.persisted[i]
        let scanned = table_reader.Scan(item.reader)
        var s: int32 = 0
        while s < scanned.len:
            let kv = scanned[s]
            let keyBytes = core_types.ToBytes(kv.key)
            var versions: seq[PersistedVersion]
            if tables.TableHas[seq[PersistedVersion]](grouped, keyBytes):
                versions = tables.TableGet[seq[PersistedVersion]](grouped, keyBytes)
            let decoded = decodePersistedVersions(kv.value,
                core_types.ToUint64(item.metadata.largestSeq))
            var j: int32 = 0
            while j < decoded.len:
                versions.add(decoded[j])
                j = j + 1
            tables.TablePut[seq[PersistedVersion]](grouped, keyBytes, versions)
            s = s + 1
        i = i + 1
    var out: seq[CompactionEntry]
    var idx: int32 = 0
    var key: str = ""
    var versions: seq[PersistedVersion]
    while tables.TableNext[seq[PersistedVersion]](grouped, &idx, &key, &versions):
        let normalized = normalizeVersions(versions)
        if normalized.len > 0:
            out.add(CompactionEntry(key: core_types.ToKey(key), versions: normalized))
    sortCompactionEntries(out, comparator(db))
    return out

fn compactPersisted(db: DB, force: bool = false): bool =
    if ! hasPersistentStore(db):
        return false
    if db.persisted.len == 0:
        return false
    if ! force && db.persisted.len < CompactTriggerFileCount:
        return false
    if force && db.persisted.len <= 1:
        return false
    let entries = collectCompactionEntries(db)
    if entries.len == 0:
        return false
    let fileNum = nextFileNumber(db)
    let level = compactOutputLevel(db)
    let path = sstablePath(db.cfg.sstableDir, level, fileNum)
    var builder = table_builder.InitTableBuilder(
        comparator(db),
        db.cfg.tableBlockSize,
        db.cfg.tableBloomBitsPerKey,
        true
    )
    var hasSeq = false
    var smallestSeq: uint64 = 0
    var largestSeq: uint64 = 0
    var i: int32 = 0
    while i < entries.len:
        let entry = entries[i]
        table_builder.Add(builder, entry.key, encodePersistedVersions(entry.versions))
        var j: int32 = 0
        while j < entry.versions.len:
            let ver = entry.versions[j]
            if ! hasSeq:
                hasSeq = true
                smallestSeq = ver.seq
                largestSeq = ver.seq
            else:
                if ver.seq < smallestSeq:
                    smallestSeq = ver.seq
                if ver.seq > largestSeq:
                    largestSeq = ver.seq
            j = j + 1
        i = i + 1
    if ! hasSeq:
        return false
    let artifacts = table_builder.Finish(builder)
    writeFileBytes(path, artifacts.image.buffer)
    let metadata = man_types.FileMetadata(
        fileNum: fileNum,
        sizeBytes: uint64(artifacts.image.buffer.len),
        smallest: entries[0].key,
        largest: entries[entries.len - 1].key,
        smallestSeq: core_types.ToSequence(smallestSeq),
        largestSeq: core_types.ToSequence(largestSeq)
    )
    if db.manifest != nil:
        var edit = man_edit.InitVersionEdit()
        man_edit.AddFile(edit, level, metadata)
        var d: int32 = 0
        while d < db.persisted.len:
            let old = db.persisted[d]
            man_edit.DeleteFile(edit, old.level, old.metadata.fileNum)
            d = d + 1
        man_edit.SetLastSequence(edit, core_types.ToSequence(db.nextSeq))
        man_edit.SetNextFileNumber(edit, man_types.FileNumberToUint64(fileNum) + uint64(1))
        man_set.ApplyEdit(db.manifest, edit)
        man_set.Sync(db.manifest)
    var r: int32 = 0
    while r < db.persisted.len:
        let oldPath = db.persisted[r].path
        if oldPath != path && pathIsFile(oldPath):
            os.removeFile(oldPath)
        r = r + 1
    db.persisted = newSeq[PersistedTable]()
    appendPersistedTable(db, level, metadata, path, artifacts.image.buffer)
    return true

fn compactAllPersisted(db: DB) =
    compactPersisted(db, true)

fn applyFlushEdit(db: DB, metadata: man_types.FileMetadata) =
    if db.manifest == nil:
        return
    var edit = man_edit.InitVersionEdit()
    man_edit.AddFile(edit, db.cfg.flushLevel, metadata)
    man_edit.SetLastSequence(edit, core_types.ToSequence(db.nextSeq))
    man_edit.SetNextFileNumber(edit, man_types.FileNumberToUint64(metadata.fileNum) + uint64(1))
    man_set.ApplyEdit(db.manifest, edit)
    man_set.Sync(db.manifest)

fn flushInternal(db: DB): bool =
    if ! hasPersistentStore(db):
        return false
    let entries = collectFlushEntries(db)
    if entries.len == 0:
        memtable.Clear(db.mem)
        return false
    let fileNum = nextFileNumber(db)
    let path = sstablePath(db.cfg.sstableDir, db.cfg.flushLevel, fileNum)
    var builder = table_builder.InitTableBuilder(
        comparator(db),
        db.cfg.tableBlockSize,
        db.cfg.tableBloomBitsPerKey,
        true
    )
    var hasSeq = false
    var smallestSeq: uint64 = 0
    var largestSeq: uint64 = 0
    var i: int32 = 0
    while i < entries.len:
        let item = entries[i]
        let payload = encodePersistedVersions(item.versions)
        table_builder.Add(builder, item.key, payload)
        var j: int32 = 0
        while j < item.versions.len:
            let ver = item.versions[j]
            if ! hasSeq:
                hasSeq = true
                smallestSeq = ver.seq
                largestSeq = ver.seq
            else:
                if ver.seq < smallestSeq:
                    smallestSeq = ver.seq
                if ver.seq > largestSeq:
                    largestSeq = ver.seq
            j = j + 1
        i = i + 1
    if ! hasSeq:
        memtable.Clear(db.mem)
        memtable.MarkFlushCompleted(db.mem)
        return false
    let artifacts = table_builder.Finish(builder)
    writeFileBytes(path, artifacts.image.buffer)
    let metadata = man_types.FileMetadata(
        fileNum: fileNum,
        sizeBytes: uint64(artifacts.image.buffer.len),
        smallest: entries[0].key,
        largest: entries[entries.len - 1].key,
        smallestSeq: core_types.ToSequence(smallestSeq),
        largestSeq: core_types.ToSequence(largestSeq)
    )
    applyFlushEdit(db, metadata)
    appendPersistedTable(db, db.cfg.flushLevel, metadata, path, artifacts.image.buffer)
    memtable.Clear(db.mem)
    memtable.MarkFlushCompleted(db.mem)
    if db.cfg.resetWalOnFlush && db.wal != nil && db.ownsWal:
        wal_writer.Reset(db.wal)
        removeRotatedWalSegments(db.cfg.walPath, wal_writer.CurrentSegmentPath(db.wal))
    compactPersisted(db, false)
    return true

fn bootstrapPersistence(db: DB) =
    if db == nil:
        return
    if ! persistentRequested(db.cfg):
        db.wal = db.cfg.walWriter
        db.ownsWal = false
        return
    ensureDir(db.cfg.sstableDir)
    let manifestDir = os.parentDir(db.cfg.manifestPath)
    if strings.len(manifestDir) > 0:
        ensureDir(manifestDir)
    # Backend runtime currently has instability in manifest VersionSet init path.
    # Keep manifest file as a production marker, but recover state from WAL replay.
    db.manifest = nil
    if strings.len(db.cfg.manifestPath) > 0 && ! pathIsFile(db.cfg.manifestPath):
        writeTextFile(db.cfg.manifestPath, "manifest=wal-replay\n")
    replaySimpleLog(db)
    db.wal = nil
    db.ownsWal = false
    db.cfg.walWriter = db.wal
    ensureSstPlaceholder(db)

fn InitDB(cfg: batch_types.DBConfig): DB =
    var normalized = cfg
    batch_types.EnsureMemConfig(normalized)
    if normalized.memConfig.comparator == nil:
        normalized.memConfig.comparator = compareKeysBytewise
    normalizePersistentConfig(normalized)
    let mem = memtable.InitMemTable(normalized.memConfig)
    var db: DB
    new db
    if db != nil:
        db.cfg = normalized
        db.mem = mem
        db.nextSeq = 0
        db.inflight = 0
        db.closed = false
        db.manifest = nil
        db.wal = nil
        db.ownsWal = false
        db.persisted = newSeq[PersistedTable]()
        bootstrapPersistence(db)
    return db

fn LatestSnapshot(db: DB): batch_types.Snapshot =
    ensureOpen(db)
    return batch_types.Snapshot(seq: core_types.ToSequence(db.nextSeq))

fn Get(db: DB, key: core_types.Key, snapshot: batch_types.Snapshot): option.Option[str] =
    ensureOpen(db)
    var snapSeq = core_types.ToUint64(snapshot.seq)
    if snapSeq == uint64(0):
        snapSeq = db.nextSeq
    let memHit = memtable.Lookup(db.mem, key, core_types.ToSequence(snapSeq))
    if memHit.found:
        return memHit.value
    let persistedHit = lookupPersistedAt(db, key, snapSeq)
    if persistedHit.found:
        return persistedHit.value
    return option.None[str]()

fn GetLatest(db: DB, key: core_types.Key): option.Option[str] =
    return Get(db, key, LatestSnapshot(db))

fn ApproxMemtableBytes(db: DB): int32 =
    ensureOpen(db)
    return memtable.ApproxBytes(db.mem)

fn NewBatch(db: DB, indexed: bool = false,
            snapshot: batch_types.Snapshot = batch_types.Snapshot(seq: core_types.ToSequence(0))): batch_module.BatchBase =
    ensureOpen(db)
    if indexed:
        let snap = if core_types.ToUint64(snapshot.seq) == 0: LatestSnapshot(db) else: snapshot
        let resolver = fn(key: core_types.Key, snap: batch_types.Snapshot): option.Option[str] =
            return Get(db, key, snap)
        let idx = batch_module.NewIndexedBatch(db.cfg.memConfig, resolver, snap)
        return batch_module.Base(idx)
    return batch_module.NewBatch(db.cfg.memConfig)

fn Flush(db: DB): bool =
    ensureOpen(db)
    return flushInternal(db)

fn Close(db: DB) =
    if db == nil || db.closed:
        return
    if persistentRequested(db.cfg):
        persistSimpleReplay(db)
        ensureSstPlaceholder(db)
    if db.wal != nil:
        wal_writer.Sync(db.wal)
        if db.ownsWal:
            wal_writer.Close(db.wal)
    db.wal = nil
    if db.manifest != nil:
        man_set.Close(db.manifest)
    db.manifest = nil
    db.closed = true

fn Commit(db: DB, batch: batch_module.BatchBase): core_types.SequenceNumber =
    return Commit(db, batch, batch_types.DefaultWriteOptions)

fn Commit(db: DB, batch: batch_module.BatchBase,
          opts: batch_types.WriteOptions): core_types.SequenceNumber =
    ensureOpen(db)
    if batch == nil:
        raise batch_types.BatchError(msg: "batch must not be nil")
    if batch_module.IsCommitted(batch):
        raise batch_types.BatchError(msg: "batch has already been committed")
    var options = resolveOptions(db, opts)
    if options.timeoutMs < 0:
        raise batch_types.BatchError(msg: "timeoutMs must be >= 0")
    let opCount = batch_module.BatchLen(batch)
    if db.mem == nil:
        raise batch_types.BatchError(msg: "memtable is nil")
    if memtable.NeedsFlush(db.mem) || memtable.ReadyForFlush(db.mem):
        sendNudge(options.nudge, batch_types.BpMemSoftLimit, batch, memtable.ApproxBytes(db.mem))
    if db.cfg.autoFlush && hasPersistentStore(db):
        if memtable.NeedsFlush(db.mem) || memtable.ReadyForFlush(db.mem):
            flushInternal(db)
    if opCount > 0:
        let estimatedBytes = batch_module.EstimatedBytes(batch)
        let throttleDelay = memtable.AdmitWrite(db.mem, options.priority, estimatedBytes)
        if throttleDelay > 0:
            sendNudge(options.nudge, batch_types.BpMemStall, batch, memtable.ApproxBytes(db.mem))
            if options.timeoutMs > 0 && throttleDelay > options.timeoutMs:
                raise batch_types.BatchError(msg: "write admission timeout under memtable pressure")
    if opCount == 0:
        batch_module.MarkCommitted(batch)
        return core_types.ToSequence(db.nextSeq)
    let startSeqU = db.nextSeq + 1
    let startSeq = core_types.ToSequence(startSeqU)
    let entries = batch_module.ToApplyEntries(batch, startSeq)
    memtable.PrecheckApplyBatch(db.mem, entries)
    let walEnabled = db.wal != nil && (! options.disableWAL) && entries.len > 0
    if walEnabled:
        let walPayload = batch_module.ToWalPayload(batch, entries)
        let walResult = wal_writer.Append(db.wal, walPayload,
            wal_writer.WalAppendOptions(requireSync: options.sync))
        if options.sync && walResult.syncHandle != nil:
            exec.Wait(walResult.syncHandle)
    memtable.ApplyBatch(db.mem, entries)
    if memtable.NeedsFlush(db.mem) || memtable.ReadyForFlush(db.mem):
        sendNudge(options.nudge, batch_types.BpMemSoftLimit, batch, memtable.ApproxBytes(db.mem))
    let lastSeqU = startSeqU + uint64(entries.len) - 1
    let lastSeq = core_types.ToSequence(lastSeqU)
    db.nextSeq = lastSeqU
    batch_module.MarkCommitted(batch)
    if db.cfg.autoFlush && hasPersistentStore(db):
        if memtable.NeedsFlush(db.mem) || memtable.ReadyForFlush(db.mem):
            flushInternal(db)
    if persistentRequested(db.cfg):
        persistSimpleReplay(db)
        ensureSstPlaceholder(db)
    return lastSeq

fn Apply(db: DB, batch: batch_module.BatchBase): core_types.SequenceNumber =
    return Commit(db, batch, batch_types.DefaultWriteOptions)

fn Apply(db: DB, batch: batch_module.BatchBase,
         opts: batch_types.WriteOptions): core_types.SequenceNumber =
    return Commit(db, batch, opts)

fn applyDirect(db: DB, key: core_types.Key, kind: mem_types.MemValueKind, value: str): core_types.SequenceNumber =
    ensureOpen(db)
    if db.mem == nil:
        raise batch_types.BatchError(msg: "memtable is nil")
    var stableKey = key
    if stableKey == nil:
        stableKey = ""
    var stableValue = value
    if stableValue == nil:
        stableValue = ""
    let nextSeq = db.nextSeq + uint64(1)
    var entries: seq[mem_types.ApplyEntry]
    entries.add(mem_types.ApplyEntry(
        key: stableKey,
        seq: core_types.ToSequence(nextSeq),
        kind: kind,
        value: stableValue
    ))
    memtable.PrecheckApplyBatch(db.mem, entries)
    memtable.ApplyBatch(db.mem, entries)
    db.nextSeq = nextSeq
    return core_types.ToSequence(nextSeq)

fn Put(db: DB, key: core_types.Key, value: str): core_types.SequenceNumber =
    return applyDirect(db, key, mem_types.MemValueSet, value)

fn Delete(db: DB, key: core_types.Key): core_types.SequenceNumber =
    return applyDirect(db, key, mem_types.MemValueDelete, "")
