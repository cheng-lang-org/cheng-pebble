module pebble_tooling_sstable_commands

import cheng/pebble/core/text as text
import cheng/pebble/sstable/types as sstable_types
import cheng/pebble/sstable/table_reader as table_reader
import cheng/pebble/core/types as core_types
import cheng/pebble/tooling/cli_core as cli_core
import std/bytes as bytes
import std/option as option
import std/strings as strings
import std/strutils as strutils
import std/os as os
import std/system as sys


type
    TableDigest =
        path: str
        size: int32
        sections: seq[sstable_types.TableSection]
        props: sstable_types.TableProperties

fn hexDigit(value: int32): char =
    if value < 10:
        return chr(int32('0') + value)
    return chr(int32('a') + value - 10)

fn StrToHex(text: str): str =
    var out: str = ""
    var i: int32 = 0
    let n: int32 = strings.len(text)
    while i < n:
        let v: int32 = int32(text[i])
        let hi = (v >> 4) & 0xF
        let lo = v & 0xF
        out = out + strings.charToStr(hexDigit(hi)) + strings.charToStr(hexDigit(lo))
        i = i + 1
    return out

fn ByteBufferToSeq(buf: bytes.ByteBuffer): seq[uint8] =
    var out = newSeq[uint8](int(buf.len))
    var i: int32 = 0
    while i < buf.len:
        let v = bytes.bufByteAt(buf, i)
        out[i] = uint8(v)
        i = i + 1
    return out

fn readTable(path: str): table_reader.TableReader =
    let dataBuf = bytes.readFileBytes(path)
    if dataBuf.len <= 0:
        raise ValueError(msg: "failed to read SSTable: " & path)
    let seqData = ByteBufferToSeq(dataBuf)
    return table_reader.NewTableReader(seqData)

fn kindLabel(kind: sstable_types.BlockKind): str =
    if kind == sstable_types.BlockData:
        return "data"
    if kind == sstable_types.BlockIndex:
        return "index"
    if kind == sstable_types.BlockFilter:
        return "filter"
    return "meta"

fn formatKey(key: core_types.Key, hexMode: bool): str =
    let text = core_types.ToBytes(key)
    if hexMode:
        return StrToHex(text)
    return text

fn formatValue(value: str, hexMode: bool): str =
    if hexMode:
        return StrToHex(value)
    return value

fn collectDigest(path: str): TableDigest =
    let reader = readTable(path)
    return TableDigest(
        path: path,
        size: table_reader.TableSize(reader),
        sections: table_reader.Sections(reader),
        props: table_reader.Properties(reader)
    )

fn renderDigest(digest: TableDigest) =
    echo("File: " & digest.path)
    echo("  Size: " & text.toText(digest.size) & " bytes")
    var counts: array[4, int32]
    var bytesByKind: array[4, int32]
    var i: int32 = 0
    while i < digest.sections.len:
        let section = digest.sections[i]
        let idx = int32(section.kind)
        counts[idx] = counts[idx] + 1
        bytesByKind[idx] = bytesByKind[idx] + section.handle.length
        i = i + 1
    var k: int32 = 0
    while k < 4:
        let kind = sstable_types.BlockKind(k)
        let label = kindLabel(kind)
        echo("  " & label & " blocks: " & text.toText(counts[k]) &
            " total bytes: " & text.toText(bytesByKind[k]))
        k = k + 1
    let props = digest.props
    echo("  Entries: " & text.toText(props.numEntries))
    echo("  Raw key bytes: " & text.toText(props.rawKeySize))
    echo("  Raw value bytes: " & text.toText(props.rawValueSize))
    if option.IsSome(props.smallestKey):
        echo("  Smallest key: " & core_types.ToBytes(option.Get(props.smallestKey)))
    if option.IsSome(props.largestKey):
        echo("  Largest key: " & core_types.ToBytes(option.Get(props.largestKey)))
    if option.IsSome(props.bloomBitsPerKey):
        echo("  Bloom bits/key: " & text.toText(option.Get(props.bloomBitsPerKey)))

fn handleLs(ctx: cli_core.CliContext, args: seq[str]) =
    ctx
    if args.len == 0 || (args.len > 0 && (args[0] == "-h" || args[0] == "--help")):
        echo("Usage:")
        echo("  " & "sstable ls <sstable>...")
        return
    var i: int32 = 0
    while i < args.len:
        let path = args[i]
        if ! os.fileExists(path):
            cli_core.RaiseCliError("file does not exist: " & path)
        let digest = collectDigest(path)
        renderDigest(digest)
        i = i + 1

fn handleDump(ctx: cli_core.CliContext, args: seq[str]) =
    ctx
    var files: seq[str]
    var limit: int32 = -1
    var hexMode: bool = false
    var i: int32 = 0
    while i < args.len:
        let arg = args[i]
        if strutils.startsWith(arg, "--limit=") || strutils.startsWith(arg, "--count="):
            let parts = strutils.split(arg, '=')
            if parts.len > 1:
                limit = int32(strutils.parseInt(parts[1]))
        elif arg == "--limit" || arg == "--count":
            cli_core.RaiseCliError("use --limit=<N> or --count=<N>")
        elif arg == "--hex":
            hexMode = true
        elif arg == "-h" || arg == "--help":
            echo("Usage:")
            echo("  sstable dump [--limit=N|--count=N] [--hex] <sstable>...")
            return
        else:
            files.add(arg)
        i = i + 1
    if files.len == 0:
        cli_core.RaiseCliError("at least one SSTable path is required")
    var f: int32 = 0
    while f < files.len:
        let path = files[f]
        if ! os.fileExists(path):
            cli_core.RaiseCliError("file does not exist: " & path)
        let reader = readTable(path)
        echo("File: " & path)
        var count: int32 = 0
        let scanned = table_reader.Scan(reader)
        var s: int32 = 0
        while s < scanned.len:
            let kv = scanned[s]
            let keyStr = formatKey(kv.key, hexMode)
            let valueStr = formatValue(kv.value, hexMode)
            echo("  " & keyStr & " : " & valueStr)
            count = count + 1
            if limit >= 0 && count >= limit:
                break
            s = s + 1
        if limit >= 0 && count >= limit:
            echo("  ...(truncated)")
        f = f + 1

fn RegisterSstableCommands(root: cli_core.CliCommand) =
    let sstableRoot = cli_core.NewCliCommand("sstable", "SSTable inspection commands")
    let lsCmd = cli_core.NewCliCommand("ls", "list SSTable block layout", handleLs)
    let dumpCmd = cli_core.NewCliCommand("dump", "dump SSTable key/value pairs", handleDump)
    cli_core.AddSubcommand(sstableRoot, lsCmd)
    cli_core.AddSubcommand(sstableRoot, dumpCmd)
    cli_core.AddSubcommand(root, sstableRoot)
