module pebble_wal_writer

import cheng/pebble/core/text as text
import cheng/pebble/runtime/executor as exec
import cheng/pebble/wal/checksum as checksum
import cheng/pebble/wal/recycler as recycler
import cheng/pebble/wal/types as wal_types
import std/strings as strings
import std/os as os
import std/option as option
import std/system as sys

@importc("cheng_fwrite")
fn wal_c_fwrite(ptr: void*, size: int32, n: int32, stream: os.File): int32
@importc("cheng_fflush")
fn wal_c_fflush(stream: os.File): int32
@importc("fileno")
fn wal_c_fileno(stream: os.File): int32
@importc("fsync")
fn wal_c_fsync(fd: int32): int32
@importc("ftruncate")
fn wal_c_ftruncate(fd: int32, length: int64): int32
@importc("fseek")
fn wal_c_fseek(stream: os.File, offset: int64, whence: int32): int32

const
    DefaultFormat = wal_types.WireRecyclable
    SeekSet = 0

type
    SegmentAllocator = fn(index: int32): str

type
    WalWriterConfig =
        allocator: SegmentAllocator
        recycler: recycler.LogRecycler
        format: wal_types.WireFormat
        logNumber: uint32
        maxSegmentBytes: int64
        executor: exec.Executor
        autoSyncOffsets: bool
        autoSyncBytes: int64
        maxPendingAutoSyncs: int32

type
    WalAppendOptions =
        requireSync: bool
        metadata: wal_types.WalRecordMetadata
        forceRotation: bool

type
    WalAppendResult =
        offset: int64
        bytesWritten: int32
        syncHandle: exec.TaskHandle
        segmentPath: str

type
    WalWriter = ref
        cfg: WalWriterConfig
        segmentIndex: int32
        segmentPath: str
        file: os.File
        blockOffset: int32
        segmentBytes: int64
        totalBytes: int64
        pending: seq[exec.TaskHandle]
        bytesSinceSync: int64
        closed: bool

fn ensureAllocator(cfg: WalWriterConfig) =
    if cfg.allocator == nil:
        raise wal_types.WalError(msg: "WAL allocator must not be nil")

fn defaultAllocator(path: str): SegmentAllocator =
    return fn(index: int32): str =
        if index == 0:
            return path
        let parts = os.splitFile(path)
        let name = parts.name & "." & text.toText(index) & parts.ext
        return os.joinPath(parts.dir, name)

fn ensureParentDir(path: str) =
    let parts = os.splitFile(path)
    let dir = parts.dir
    if dir.len > 0 && ! os.dirExists(dir):
        os.createDir(dir)

fn writeBytes(file: os.File, data: seq[uint8]) =
    if data.len == 0:
        return
    var remaining: int32 = data.len
    var offset: int32 = 0
    while remaining > 0:
        let ptr = ptr_add(data.buffer, offset)
        let wrote = wal_c_fwrite(ptr, 1, remaining, file)
        if wrote <= 0:
            raise wal_types.WalError(msg: "failed to write WAL bytes")
        offset = offset + wrote
        remaining = remaining - wrote

fn flushFile(file: os.File) =
    if file == nil:
        return
    if wal_c_fflush(file) != 0:
        raise wal_types.WalError(msg: "failed to flush WAL file")

fn syncFile(file: os.File) =
    if file == nil:
        return
    flushFile(file)
    let fd = wal_c_fileno(file)
    if fd < 0:
        raise wal_types.WalError(msg: "failed to resolve WAL file descriptor")
    if wal_c_fsync(fd) != 0:
        raise wal_types.WalError(msg: "failed to fsync WAL file")

fn padBlock(writer: WalWriter) =
    let remaining = wal_types.blockSize - writer.blockOffset
    if remaining <= 0:
        return
    var zeros = newSeq[uint8](remaining)
    writeBytes(writer.file, zeros)
    writer.blockOffset = 0
    writer.segmentBytes = writer.segmentBytes + int64(remaining)
    writer.totalBytes = writer.totalBytes + int64(remaining)

fn closeCurrentSegment(writer: WalWriter, recycle: bool) =
    if writer.file != nil:
        let pending = writer.pending
        var i: int32 = 0
        while i < pending.len:
            exec.Wait(pending[i])
            i = i + 1
        writer.pending.setLen(0)
        syncFile(writer.file)
        os.close(writer.file)
        writer.file = nil
        if recycle && writer.cfg.recycler != nil && writer.segmentPath.len > 0:
            recycler.Recycle(writer.cfg.recycler,
                recycler.RecyclableFile(path: writer.segmentPath,
                                        size: writer.segmentBytes))
    writer.blockOffset = 0
    writer.segmentBytes = 0
    writer.bytesSinceSync = 0

fn openSegment(writer: WalWriter, index: int32, recyclePrev: bool) =
    closeCurrentSegment(writer, recyclePrev)
    let path = writer.cfg.allocator(index)
    var reused = option.None[recycler.RecyclableFile]()
    if writer.cfg.recycler != nil:
        reused = recycler.Acquire(writer.cfg.recycler)
    if reused.has:
        let file = reused.value
        if file.path != path:
            os.renameFile(file.path, path)
    ensureParentDir(path)
    writer.file = os.open(path, os.fmWrite)
    if writer.file == nil:
        raise wal_types.WalError(msg: "unable to open WAL segment: " & path)
    writer.segmentPath = path
    writer.blockOffset = 0
    writer.segmentBytes = 0

fn headerSize(format: wal_types.WireFormat): int32 =
    if format == wal_types.WireLegacy:
        return wal_types.legacyHeaderSize
    if format == wal_types.WireRecyclable:
        return wal_types.recyclableHeaderSize
    if format == wal_types.WireWalSync:
        return wal_types.walSyncHeaderSize
    return 0

fn flushNow(writer: WalWriter): exec.TaskHandle =
    writer.cfg.executor
    syncFile(writer.file)
    return nil

fn cleanupPending(writer: WalWriter) =
    if writer.pending.len == 0:
        return
    var active = newSeq[exec.TaskHandle]()
    let pending = writer.pending
    var i: int32 = 0
    while i < pending.len:
        let handle = pending[i]
        if handle == nil:
            i = i + 1
            continue
        if exec.IsPending(handle):
            active.add(handle)
        else:
            exec.Wait(handle)
        i = i + 1
    writer.pending = active

fn trackPending(writer: WalWriter, handle: exec.TaskHandle) =
    if handle == nil:
        return
    cleanupPending(writer)
    if writer.cfg.maxPendingAutoSyncs > 0:
        while writer.pending.len >= writer.cfg.maxPendingAutoSyncs:
            let waitHandle = writer.pending[0]
            writer.pending.delete(0)
            exec.Wait(waitHandle)
            cleanupPending(writer)
    writer.pending.add(handle)

fn maybeAutoSync(writer: WalWriter, bytesWritten: int32) =
    if bytesWritten <= 0 || writer.cfg.autoSyncBytes <= 0:
        return
    writer.bytesSinceSync = writer.bytesSinceSync + int64(bytesWritten)
    if writer.bytesSinceSync >= writer.cfg.autoSyncBytes:
        let handle = flushNow(writer)
        if handle != nil:
            trackPending(writer, handle)
        writer.bytesSinceSync = 0

fn writeChunk(writer: WalWriter,
              chunkType: wal_types.ChunkType,
              payload: seq[uint8],
              metadata: wal_types.WalRecordMetadata) =
    var header = newSeq[uint8](headerSize(writer.cfg.format))
    let payloadLen = uint16(payload.len)
    var crc = checksum.Extend(uint32(0), checksum.FromByte(uint8(chunkType)))
    if wal_types.IsReusable(writer.cfg.format):
        crc = checksum.Extend(crc, checksum.FromUInt32(metadata.logNumber))
    if wal_types.HasSyncOffset(writer.cfg.format):
        crc = checksum.Extend(crc, checksum.FromUInt64(metadata.syncOffset))
    if payload.len > 0:
        crc = checksum.Extend(crc, payload)
    let checksumMasked = checksum.MaskChecksum(crc)
    header[0] = uint8(checksumMasked & uint32(0xFF))
    header[1] = uint8((checksumMasked >> 8) & uint32(0xFF))
    header[2] = uint8((checksumMasked >> 16) & uint32(0xFF))
    header[3] = uint8((checksumMasked >> 24) & uint32(0xFF))
    header[4] = uint8(payloadLen & uint16(0xFF))
    header[5] = uint8((payloadLen >> 8) & uint16(0xFF))
    header[6] = uint8(chunkType)
    var idx: int32 = 7
    if wal_types.IsReusable(writer.cfg.format):
        let logBytes = checksum.FromUInt32(metadata.logNumber)
        var i: int32 = 0
        while i < 4:
            header[idx] = logBytes[i]
            idx = idx + 1
            i = i + 1
    if wal_types.HasSyncOffset(writer.cfg.format):
        let syncBytes = checksum.FromUInt64(metadata.syncOffset)
        var i: int32 = 0
        while i < 8:
            header[idx] = syncBytes[i]
            idx = idx + 1
            i = i + 1
    writeBytes(writer.file, header)
    writeBytes(writer.file, payload)
    writer.blockOffset = writer.blockOffset + header.len + payload.len
    writer.segmentBytes = writer.segmentBytes + int64(header.len + payload.len)
    writer.totalBytes = writer.totalBytes + int64(header.len + payload.len)

fn rotateIfNeeded(writer: WalWriter, force: bool) =
    if force || (writer.cfg.maxSegmentBytes > 0 && writer.segmentBytes >= writer.cfg.maxSegmentBytes):
        writer.segmentIndex = writer.segmentIndex + 1
        openSegment(writer, writer.segmentIndex, true)

fn NewWalWriterWithConfig(cfg: WalWriterConfig): WalWriter =
    ensureAllocator(cfg)
    var normalized = cfg
    if normalized.autoSyncBytes < 0:
        normalized.autoSyncBytes = 0
    if normalized.maxPendingAutoSyncs < 0:
        normalized.maxPendingAutoSyncs = 0
    var writer: WalWriter
    new writer
    if writer == nil:
        return writer
    writer.cfg = normalized
    writer.segmentIndex = 0
    writer.pending = newSeq[exec.TaskHandle]()
    writer.totalBytes = 0
    writer.bytesSinceSync = 0
    writer.closed = false
    openSegment(writer, writer.segmentIndex, false)
    return writer

fn NewWalWriter(path: str,
                format: wal_types.WireFormat = DefaultFormat,
                logNumber: uint32 = 0,
                maxSegmentBytes: int64 = 0,
                recycler: recycler.LogRecycler = nil,
                executor: exec.Executor = nil,
                autoSyncOffsets: bool = true,
                autoSyncBytes: int64 = 0,
                maxPendingAutoSyncs: int32 = 0): WalWriter =
    let cfg = WalWriterConfig(
        allocator: defaultAllocator(path),
        recycler: recycler,
        format: format,
        logNumber: logNumber,
        maxSegmentBytes: maxSegmentBytes,
        executor: executor,
        autoSyncOffsets: autoSyncOffsets,
        autoSyncBytes: autoSyncBytes,
        maxPendingAutoSyncs: maxPendingAutoSyncs
    )
    return NewWalWriterWithConfig(cfg)

fn Append(writer: WalWriter,
          payload: seq[uint8],
          options: WalAppendOptions = WalAppendOptions()): WalAppendResult =
    if writer == nil || writer.closed:
        raise wal_types.WalError(msg: "wal writer already closed")
    if options.forceRotation:
        rotateIfNeeded(writer, true)
    var metadata = options.metadata
    if metadata.logNumber == uint32(0):
        metadata.logNumber = writer.cfg.logNumber
    var recordOffset: int64 = -1
    var recordSegmentPath = writer.segmentPath
    let headerBytes = headerSize(writer.cfg.format)
    var writtenBytes: int32 = 0
    let totalLen = payload.len
    if totalLen == 0:
        if writer.cfg.maxSegmentBytes > 0 &&
           writer.segmentBytes + int64(headerBytes) > writer.cfg.maxSegmentBytes &&
           writer.segmentBytes > 0:
            rotateIfNeeded(writer, true)
        if wal_types.blockSize - writer.blockOffset < headerBytes:
            padBlock(writer)
        if recordOffset < 0:
            recordOffset = writer.segmentBytes
            recordSegmentPath = writer.segmentPath
        var chunkMeta = metadata
        let chunkStart = writer.segmentBytes
        if wal_types.HasSyncOffset(writer.cfg.format):
            if chunkMeta.syncOffset == 0 && writer.cfg.autoSyncOffsets:
                chunkMeta.syncOffset = uint64(chunkStart + int64(headerBytes))
            elif chunkMeta.syncOffset < uint64(chunkStart):
                raise wal_types.WalError(msg: "sync offset regression detected")
        writeChunk(writer, wal_types.ChunkTypeFor(wal_types.ChunkPosFull, writer.cfg.format), newSeq[uint8](), chunkMeta)
        writtenBytes = headerBytes
    else:
        var remaining = totalLen
        var cursor: int32 = 0
        while remaining > 0:
            if wal_types.blockSize - writer.blockOffset < headerBytes:
                padBlock(writer)
                continue
            let usable = max(0, wal_types.blockSize - writer.blockOffset - headerBytes)
            if usable == 0:
                padBlock(writer)
                continue
            let chunkLen = min(remaining, usable)
            if writer.cfg.maxSegmentBytes > 0 &&
               writer.segmentBytes + (int64(headerBytes) + int64(chunkLen)) > writer.cfg.maxSegmentBytes &&
               writer.segmentBytes > 0:
                rotateIfNeeded(writer, true)
                continue
            let position =
                if cursor == 0 && chunkLen == remaining: wal_types.ChunkPosFull
                elif cursor == 0: wal_types.ChunkPosFirst
                elif chunkLen == remaining: wal_types.ChunkPosLast
                else: wal_types.ChunkPosMiddle
            let chunkType = wal_types.ChunkTypeFor(position, writer.cfg.format)
            if chunkType == wal_types.ChunkInvalid:
                raise wal_types.WalError(msg: "invalid chunk type encoding")
            var chunkData = newSeq[uint8](chunkLen)
            var i: int32 = 0
            while i < chunkLen:
                chunkData[i] = payload[cursor + i]
                i = i + 1
            var chunkMeta = metadata
            let chunkStart = writer.segmentBytes
            let chunkAdvance = int64(headerBytes) + int64(chunkLen)
            if wal_types.HasSyncOffset(writer.cfg.format):
                if chunkMeta.syncOffset == 0 && writer.cfg.autoSyncOffsets:
                    chunkMeta.syncOffset = uint64(chunkStart + chunkAdvance)
                elif chunkMeta.syncOffset < uint64(chunkStart):
                    raise wal_types.WalError(msg: "sync offset regression detected")
            if recordOffset < 0:
                recordOffset = chunkStart
                recordSegmentPath = writer.segmentPath
            writeChunk(writer, chunkType, chunkData, chunkMeta)
            remaining = remaining - chunkLen
            cursor = cursor + chunkLen
            writtenBytes = writtenBytes + headerBytes + chunkLen
    if recordOffset < 0:
        recordOffset = writer.segmentBytes
        recordSegmentPath = writer.segmentPath
    var result = WalAppendResult(offset: recordOffset,
                                 bytesWritten: writtenBytes,
                                 syncHandle: nil,
                                 segmentPath: recordSegmentPath)
    if options.requireSync:
        if writer.cfg.autoSyncBytes > 0:
            writer.bytesSinceSync = writer.bytesSinceSync + int64(writtenBytes)
        let handle = flushNow(writer)
        writer.bytesSinceSync = 0
        result.syncHandle = handle
    else:
        maybeAutoSync(writer, writtenBytes)
    return result

fn AppendString(writer: WalWriter, payload: str,
                options: WalAppendOptions = WalAppendOptions()): WalAppendResult =
    var data = newSeq[uint8](payload.len)
    var i: int32 = 0
    while i < payload.len:
        data[i] = uint8(int32(payload[i]))
        i = i + 1
    return Append(writer, data, options)

fn Close(writer: WalWriter) =
    if writer == nil || writer.closed:
        return
    closeCurrentSegment(writer, true)
    writer.closed = true

fn TrimTail(writer: WalWriter) =
    if writer == nil || writer.file == nil:
        return
    let pending = writer.pending
    var i: int32 = 0
    while i < pending.len:
        exec.Wait(pending[i])
        i = i + 1
    writer.pending.setLen(0)
    writer.bytesSinceSync = 0
    let fd = wal_c_fileno(writer.file)
    if fd >= 0 && writer.segmentBytes >= 0:
        if wal_c_ftruncate(fd, writer.segmentBytes) != 0:
            raise wal_types.WalError(msg: "failed to truncate WAL tail")
    syncFile(writer.file)

fn Sync(writer: WalWriter) =
    if writer == nil || writer.file == nil:
        return
    let pending = writer.pending
    var i: int32 = 0
    while i < pending.len:
        exec.Wait(pending[i])
        i = i + 1
    writer.pending.setLen(0)
    writer.bytesSinceSync = 0
    syncFile(writer.file)

fn CurrentSegmentPath(writer: WalWriter): str =
    if writer == nil:
        return ""
    return writer.segmentPath

fn Reset(writer: WalWriter) =
    if writer == nil || writer.file == nil:
        return
    let pending = writer.pending
    var i: int32 = 0
    while i < pending.len:
        exec.Wait(pending[i])
        i = i + 1
    writer.pending.setLen(0)
    writer.bytesSinceSync = 0
    flushFile(writer.file)
    let fd = wal_c_fileno(writer.file)
    if fd < 0:
        raise wal_types.WalError(msg: "failed to resolve WAL file descriptor")
    if wal_c_ftruncate(fd, 0) != 0:
        raise wal_types.WalError(msg: "failed to reset WAL file")
    if wal_c_fseek(writer.file, 0, SeekSet) != 0:
        raise wal_types.WalError(msg: "failed to seek WAL file to start")
    writer.segmentBytes = 0
    writer.blockOffset = 0
    writer.totalBytes = 0
    syncFile(writer.file)
